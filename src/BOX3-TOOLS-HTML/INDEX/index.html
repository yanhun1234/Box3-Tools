<!DOCTYPE html>
<html>

<head>
    <title>BOX3-Tools</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/3.3.7/css/bootstrap.min.css">
    <script src="https://cdn.staticfile.org/jquery/2.1.1/jquery.min.js"></script>
    <script src="https://cdn.staticfile.org/twitter-bootstrap/3.3.7/js/bootstrap.min.js"></script>
    <style>
        #cnblogs_post_body .cnblogs_code {
            /* background-color: rgba(152, 147, 147, 0.28); */
            /* border: 1px solid rgba(255, 251, 251, 0); */
            border-radius: 4px;
            color: #000;
            font-family: Courier New !important;
            font-size: 13px !important;
            margin: 5px 0;
            overflow: auto;
            padding: 5px;
        }

        .hljs-built_in,
        .hljs-keyword,
        .hljs-name,
        .hljs-selector-tag,
        .hljs-tag {
            color: #332870 !important;
        }

        .hljs-emphasis,
        .hljs-strong {
            color: #a8a8a2 !important;
        }

        .hljs-built_in,
        .hljs-keyword,
        .hljs-name,
        .hljs-selector-tag,
        .hljs-tag {
            color: #bababa !important;
        }

        .hljs-bullet,
        .hljs-link,
        .hljs-literal,
        .hljs-number,
        .hljs-quote,
        .hljs-regexp {
            color: #27c94a !important;
        }

        .hljs-code,
        .hljs-selector-class {
            color: #eeff00 !important;
        }

        .hljs-emphasis {
            font-style: italic !important;
        }

        .hljs-attribute,
        .hljs-keyword,
        .hljs-name,
        .hljs-section,
        .hljs-selector-tag,
        .hljs-variable {
            color: #00c3ff !important;
        }

        .hljs-attr,
        .hljs-params {
            color: #b9b9b9 !important;
        }

        .hljs-string {
            color: #ffbb00 !important;
        }

        .hljs-addition,
        .hljs-built_in,
        .hljs-builtin-name,
        .hljs-selector-attr,
        .hljs-selector-id,
        .hljs-selector-pseudo,
        .hljs-subst,
        .hljs-symbol,
        .hljs-template-tag,
        .hljs-template-variable,
        .hljs-title,
        .hljs-type {
            color: #dfe231 !important;
        }

        .hljs-comment,
        .hljs-deletion {
            color: #008839 !important;
        }

        .hljs-meta {
            color: #00ff0d !important;
        }

        #cnblogs_post_body .toc ul {
            max-height: 550px;
            overflow-y: auto;
        }

        .cnblogs-markdown .hljs {
            display: block;
            overflow-x: auto;
            padding: 0.5em !important;
            background: #2b2b2b !important;
            font-size: 14px !important;
            color: #bababa !important;
            font-family: Source Code Pro, Consolas, Menlo, Monaco, Courier New,
                monospace !important;
        }

        #cnblogs_post_body h1::before {
            content: "H1";
            margin-right: 10px;
            color: gainsboro;
        }

        #cnblogs_post_body h2::before {
            content: "H2";
            margin-right: 10px;
            color: gainsboro;
        }

        #cnblogs_post_body h3::before {
            content: "H3";
            margin-right: 10px;
            color: gainsboro;
        }

        #mainContent #post_detail #cnblogs_post_body h4::before {
            content: "h4";
            margin-right: 10px;
            color: gainsboro;
        }

        #cnblogs_post_body h5::before {
            content: "h5";
            margin-right: 10px;
            color: gainsboro;
        }

        #cnblogs_post_body h6::before {
            content: "h6";
            margin-right: 10px;
            color: gainsboro;
        }

        #cnblogs_post_body td.hljs-ln-numbers {
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;

            text-align: center;
            color: #ccc;
            border-right: 1px solid #ccc;
            vertical-align: top;
            padding-right: 5px;

            /* your custom style here */
        }

        #cnblogs_post_body .hljs td {
            border-collapse: inherit;
            min-width: unset;
            padding-left: 20px;
            padding-right: 10px;
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="row clearfix">
            <div class="col-md-12 column">
                <h3 class="text-center">
                    BOX3-Tools主页面
                </h3>
            </div>
        </div>
        <div class="panel-group" id="panels-1">
            <div class="panel panel-default">
                <div class="panel-heading">
                    <a class="panel-title collapsed" data-toggle="collapse" data-parent="#panels-1"
                        href="#panel-element-MAIN-1">官方教程</a>
                </div>
                <div id="panel-element-MAIN-1" class="panel-collapse collapse">
                    <div class="panel-body">
                        <div class="row clearfix">
                            <div class="col-md-12 column">
                                <blockquote>
                                    <h2>
                                        官方教程
                                    </h2>
                                </blockquote>
                                <div class="panel-group" id="panel-586155">
                                    <div class="panel panel-default">
                                        <div class="panel-heading">
                                            <a class="panel-title collapsed" data-toggle="collapse"
                                                data-parent="#panel-586155" href="#panel-element-1">变成模型+自定义出生点</a>
                                        </div>
                                        <div id="panel-element-1" class="panel-collapse collapse">
                                            <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
                                                <pre>
            <code class="language-js">
              /**
 * !info {Project} -来自(shequ.codemao.cn/community/371088)@吉吉喵
 * 有不少同学都在问的代码教程来咯！
 * 分别是让自己变成模型的样子
 * 以及自定义出生点！
 */



// 1.变成模型
for (const e of world.querySelectorAll('*')) {
    e.collides = true //实体可以被碰撞
    e.fixed = true //实体固定位置
    e.onEntityContact(({ other }) => {
        if (other.isPlayer) { // 如果跟当前实体碰撞的是玩家实体
            e.destroy()  //当前实体消失
            other.player.invisible = true // 玩家皮肤隐藏
            other.mesh = e.mesh // 玩家的外形换成当前实体的外形
            other.meshScale.copy(e.meshScale) // 玩家外形的缩放比例设成跟当前实体一样
            other.player.scale = e.meshScale.scale(e.bounds.y / other.bounds.y) //喵家的隐形碰撞盒缩放到模型刚好贴地
        }
    })
}


// 如果模型的朝向有问题
// 那么就要修正一下方向：
const Quat = new Box3Quaternion(0, 0, 0, 1)
for (const e of world.querySelectorAll('*')) {
    e.collides = true
    e.fixed = true
    e.onEntityContact(({ other }) => {
        if (other.isPlayer) { // 如果跟当前实体碰撞的是玩家实体
            other.player.invisible = true // 玩家皮肤隐藏
            other.mesh = e.mesh // 玩家的外形换成当前实体的外形
            other.meshScale.copy(e.meshScale) // 玩家外形的缩放比例设成跟当前实体一样

            //如果模型方向不正确, 则建议在模型编辑器里把模型转向修正

            // 也可以尝试下面其中一行代码, 但不同的模型需要转的角度不同, 无法通用
            // other.meshOrientation = Quat.rotateY(Math.PI) // 如果模型方向不对, 尝试旋转180度来修正, Math.PI是180度的弧度值
            // other.meshOrientation = Quat.rotateY(Math.PI/2) // 如果模型方向不对, 尝试旋转90度来修正
            // other.meshOrientation = Quat.rotateY(-Math.PI/2) // 如果模型方向不对, 尝试旋转-90度来修正

            other.player.scale = e.meshScale.scale(e.bounds.y / other.bounds.y) //喵家的隐形碰撞盒缩放到模型刚好贴地
        }
    })
}



// 2.自定义出生点

// 在某个坐标出生的4种写法：  
world.onPlayerJoin(({entity})=>{
    entity.player.spawnPoint.set(4, 11, 4)
    entity.player.forceRespawn()
})
world.onPlayerJoin(({entity})=>{
    entity.player.spawnPoint.set(4, 11, 4)
    entity.position.copy(entity.player.spawnPoint)
})
world.onPlayerJoin(({entity})=>{
    entity.player.spawnPoint = new Box3Vector3(4, 11, 4)
    entity.player.forceRespawn()
})
world.onPlayerJoin(({entity})=>{
    entity.player.spawnPoint = new Box3Vector3(4, 11, 4)
    entity.position.copy(entity.player.spawnPoint)
})

// 在某个模型的位置出生：
world.onPlayerJoin(({entity})=>{
    entity.player.spawnPoint = world.querySelector('#出生点').position
    entity.position.copy(entity.player.spawnPoint)
    entity.position.y += 10
})
            </code>
        </pre>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="panel panel-default">
                                        <div class="panel-heading">
                                            <a class="panel-title collapsed" data-toggle="collapse"
                                                data-parent="#panel-586155" href="#panel-element-2">吃了蘑菇会变身</a>
                                        </div>
                                        <div id="panel-element-2" class="panel-collapse collapse">
                                            <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
                                                <pre>
            <code class="language-js">
              /**
 * !info {Project} -来自(shequ.codemao.cn/community/417036)@吉吉喵
 * 相信大家都玩了B站up主火山giegie做的《3D超级马里奥》了吧
 * （没玩过的迅速去玩！搭配视频享用更美味）
 * 本期教程的主题就是用道具改变属性
 * 让你“变大变小变无敌”～
 */



// 跳跃道具
// 获取场景中的“弹簧”实体，作为跳跃道具
const jumpProp = world.querySelector('#弹簧-1')
// 为了下面方便使用，将实体命名为 跳跃道具
jumpProp.id = "跳跃道具"
// 开启道具的实体碰撞
jumpProp.collides = true

// 加速道具
// 获取场景中的“西瓜”实体，作为加速道具
const speedProp = world.querySelector('#MC西瓜-1')
// 为了下面方便使用，将实体命名为 加速道具
speedProp.id = "加速道具"
// 开启道具的实体碰撞
speedProp.collides = true

// 罚站道具
// 获取场景中的“陷阱”实体，作为罚站道具
const trapProp = world.querySelector('#陷阱-1')
// 为了下面方便使用，将实体命名为 罚站道具
trapProp.id = "罚站道具"
// 开启道具的实体碰撞
trapProp.collides = true

// 隐身道具
// 获取场景中的“隐身卡”实体，作为隐身道具
const invisibleProp = world.querySelector('#隐身技能卡-1')
// 为了下面方便使用，将实体命名为 隐身道具
invisibleProp.id = "隐身道具"
// 开启道具的实体碰撞
invisibleProp.collides = true

// 当实体与实体发生碰撞时
world.onEntityContact(async ({ entity, other }) => {
    // 首先需要判断当前碰撞的实体是玩家类型的实体触发的
    if (entity && entity.isPlayer) {
        // 由于onEntityContact事件会因为两个实体碰撞而触发，
        // 因此，当我们确定了其中一个是“玩家”类型的实体之后(entity.isPlayer)
        // 另一个实体other 便是我们要判断的实体道具
        // 接下来会根据实体类型的不同，区分碰撞到之后对玩家产生的效果

        // 如果玩家碰到的是加速道具，那么我们希望玩家可以获得一个加速效果
        // 要对玩家的移动进行加速，可以通过修改玩家的：行走速度、行走加速度、跑步速度以及跑步加速度来实现
        if (other.id === "加速道具") {
            // 加速道具被碰到之后就删除掉它(这样才像被玩家"吃掉"了)
            other.destroy()
            // 行走速度默认为0.22，这里设置为2倍的速度
            entity.player.walkSpeed = 0.44
            // 行走加速度默认为0.19，这里设置为2倍的速度
            entity.player.walkAcceleration = 0.38
            // 跑步速度默认为0.4，这里设置为2倍的速度
            entity.player.runSpeed = 0.8
            // 跑步加速度默认为0.35，这里设置为2倍的速度
            entity.player.runAcceleration = 0.7

            entity.player.directMessage(`你获得了奔跑加速！`)

            // 设置定时器，定时时间为5000毫秒(5秒)，5秒后会触发定时器内的代码
            setTimeout(() => {
                // 将玩家的移动和跑步速度复原
                entity.player.walkSpeed = 0.22
                entity.player.walkAcceleration = 0.19
                entity.player.runSpeed = 0.4
                entity.player.runAcceleration = 0.35
            }, 5000);
        }

        // 如果玩家碰到的是跳跃道具，那么我们希望玩家可以获得一个向上跳跃的效果
        if (other.id === "跳跃道具") {
            other.destroy()
            // 设置玩家的跳跃力度为原本的两倍
            entity.player.jumpPower = 0.96 * 2

            entity.player.directMessage(`你获得了跳跃加成！`)

            // 设置定时器，定时时间为5000毫秒(5秒)，5秒后会触发定时器内的代码
            setTimeout(() => {
                // 将玩家的跳跃力度复原
                entity.player.jumpPower = 0.96
            }, 5000);
        }

        // 如果玩家碰到的是罚站道具，那么我们希望玩家完全不能移动
        if (other.id === "罚站道具") {
            other.destroy()
            // 参考“加速道具”的实现方式，只要我们喵家的行走速度、行走加速度、跑步速度以及跑步加速度都设置为0
            // 玩家就没办法走路和跑步了
            entity.player.walkSpeed = 0
            entity.player.walkAcceleration = 0

            entity.player.runSpeed = 0
            entity.player.runAcceleration = 0
            // 顺便喵家的“跳跃”给关闭了，这样一来玩家不但不能走和跑，也不能跳了
            entity.player.enableJump = false

            entity.player.directMessage(`你撞到了陷阱，暂时无法行动！`)

            // 设置定时器，定时时间为5000毫秒(5秒)，5秒后会触发定时器内的代码
            setTimeout(() => {
                // 将玩家的移动和跑步速度复原
                entity.player.walkSpeed = 0.22
                entity.player.walkAcceleration = 0.19
                entity.player.runSpeed = 0.4
                entity.player.runAcceleration = 0.35
                // 将玩家的跳跃设置打开
                entity.player.enableJump = true
            }, 5000);
        }

        // 如果玩家碰到的是隐身道具，那么我们希望玩家隐身不可见
        if (other.id === "隐身道具") {
            other.destroy()
            // 隐藏所有身体部件
            for (const bodyPart in entity.player.skinInvisible) {
                entity.player.skinInvisible[bodyPart] = true;
            }

            entity.player.directMessage(`你获得了隐身效果！`)

            // 设置定时器，定时时间为5000毫秒(5秒)，5秒后会触发定时器内的代码
            setTimeout(() => {
                // 显示所有身体部件
                for (const bodyPart in entity.player.skinInvisible) {
                    entity.player.skinInvisible[bodyPart] = false;
                }
            }, 5000);
        }
    }
})
            </code>
        </pre>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="panel panel-default">
                                        <div class="panel-heading">
                                            <a class="panel-title collapsed" data-toggle="collapse"
                                                data-parent="#panel-586155" href="#panel-element-3">宠物跟随</a>
                                        </div>
                                        <div id="panel-element-3" class="panel-collapse collapse">
                                            <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
                                                <pre>
            <code class="language-js">
              /**
 * !info {Project} -来自(shequ.codemao.cn/community/378184)@吉吉喵
 * 想拥有一只独一无二的跟随宠物吗？
 * 想成为《学习吧！小精灵》里的被精灵环绕的大神吗？
 * 学会这招，你就是岛上最靓的崽～
 */



console.clear()
const mscale = 1 / 16
const Quat = new Box3Quaternion(0, 0, 0, 1)

function buddyFollow(entity, mesh, y) {
    const buddy = world.createEntity({
        mesh,
        position: entity.position,
        meshScale: [mscale, mscale, mscale],
        gravity: false, //不受重力影响
        fixed: false, //可推移
        collides: true, //可碰撞
        friction: 0, //无摩擦力
        mass: 0.01, //非常轻
    })

    const tgPos = entity.position//僚机的目标位置
    const budPos = buddy.position//僚机的当前位置
    const facing = entity.player.facingDirection//玩家的朝向
    const ratio = 0.3//追随的灵敏度, 最好设在0.5左右, 1.0表示立即移到玩家位置

    const dist = 2 //与玩家保持的距离
    const yOffset = y //y轴位移, 保持僚机在头顶或脚下

    const ticker = world.onTick(() => {

        //要让小精灵跟在玩家背后, 需要计算xz轴的位移: 玩家朝向的反方向
        const xOffset = -facing.x * dist
        const zOffset = -facing.z * dist

        //当前位置与目标位置在xyz轴的差距
        const xDiff = tgPos.x - budPos.x
        const yDiff = tgPos.y - budPos.y
        const zDiff = tgPos.z - budPos.z

        //计算xyz方向上 当前位置向目标位置靠拢的速度
        const 喵 = (xDiff + xOffset) * ratio
        const vy = (yDiff + yOffset) * ratio
        const vz = (zDiff + zOffset) * ratio

        buddy.velocity.set(喵, vy, vz)//设置僚机速度

        if (buddy.velocity.sqrMag() > 0.005) {//速度要足够大, 才触发转向, 防止抖动
            buddy.meshOrientation = Quat.rotateY(Math.atan2(zDiff, xDiff)) //让小精灵一直面向玩家
        }
    })

    return () => {
        ticker.cancel() //关掉tick循环
        buddy.destroy() //移除僚机实体
    }
}

world.onPlayerJoin(({ entity }) => {
    entity.setPet = buddyFollow(entity, 'mesh/皮卡丘.vb', -1) //给玩家增加宠物
})

world.onPlayerLeave(({ entity }) => {
    //玩家离开地图时, 切记一定要关掉tick循环以及销毁小精灵实体, 否则随着人数增加, 服务器积累到一定程度就会崩溃
    entity.setPet() //干掉宠物
})
            </code>
        </pre>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="panel panel-default">
                                        <div class="panel-heading">
                                            <a class="panel-title collapsed" data-toggle="collapse"
                                                data-parent="#panel-586155" href="#panel-element-4">传送门</a>
                                        </div>
                                        <div id="panel-element-4" class="panel-collapse collapse">
                                            <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
                                                <pre>
            <code class="language-js">
              /**
 * !info {Project} -来自(shequ.codemao.cn/community/358096)@吉吉喵
 * player.link里的是要传送的地图的地址
 * 这里喵喵用了entiy.onInteract的API
 * 所以按E就可以执行传送
 * 但是你们可以用其他的方式哦
 * 比如发送一串字符传送等等
 * 还等你来发掘～
 */



console.clear()
var door = world.querySelector('#门')

door.enableInteract = true
door.interactRadius = 2.5

door.onInteract(({ entity }) => {
    entity.player.link('https://box3.codemao.cn/p/6a4e57e1f91817445b21')
})
            </code>
        </pre>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="panel panel-default">
                                        <div class="panel-heading">
                                            <a class="panel-title collapsed" data-toggle="collapse"
                                                data-parent="#panel-586155" href="#panel-element-5">传送至地图的指定地点</a>
                                        </div>
                                        <div id="panel-element-5" class="panel-collapse collapse">
                                            <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
                                                <pre>
            <code class="language-js">
              /**
 * !info {Project} -来自(shequ.codemao.cn/community/359895)@吉吉喵
 * 上一期我们学习了传送教程
 * 这期的小技巧是进阶版传送门
 * 教你传送到地图上任意的位置！
 */



console.clear()
var door = world.querySelector('#传送门')
door.enableInteract = true
door.interactRadius = 2
door.interactHint = '传送到瀑布上面'

door.onInteract(({ entity }) => {
    entity.position.set(61,94,46)
})


/* 或 */

console.clear()

var door1 = world.querySelector('#红门')
door1.enableInteract = true
door1.interactRadius = 2.5

var door2 = world.querySelector('#绿门')
door2.enableInteract = true
door2.interactRadius = 2.5

var door3 = world.querySelector('#蓝门')
door3.enableInteract = true
door3.interactRadius = 2.5

door1.onInteract(({ entity }) => {
    entity.position.copy(door2.position)
})

door2.onInteract(({ entity }) => {
    entity.position.copy(door3.position)
})

door3.onInteract(({ entity }) => {
    entity.position.copy(door1.position)
})

            </code>
        </pre>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="panel panel-default">
                                        <div class="panel-heading">
                                            <a class="panel-title collapsed" data-toggle="collapse"
                                                data-parent="#panel-586155" href="#panel-element-6">大范围伤害</a>
                                        </div>
                                        <div id="panel-element-6" class="panel-collapse collapse">
                                            <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
                                                <pre>
            <code class="language-js">
               /**
 * !info {Project} -来自(shequ.codemao.cn/community/377745)@吉吉喵
 * AOE，强力有效的范围性技能
 * 能够作用于多个目标
 * 是游戏中居家旅行打架必备之技能
 * 今天喵师傅就传你这招！
 */



console.clear()

const mscale = 1 / 16
const n = [-4, -3, -2, -1, 0, 1, 2, 3, 4]

// 生成一堆小人
for (let x of n) {
    for (let y of n) {
        for (let z of n) {
            const e = world.createEntity({
                mesh: 'mesh/小人.vb',
                fixed: true,
                collides: false,
                position: [x * 4 + 64, y * 3 + 16, z * 4 + 64],
                meshScale: [mscale, mscale, mscale],
            })
            e.enableDamage = true
            e.onDie(() => {
                e.destroy()
            })
        }
    }
}

world.onPlayerJoin(({ entity }) => {
    entity.enableDamage = true 
})


function killZone(pos, radius, fn) { //球状AOE
    for (const e of world.querySelectorAll('*')) {//遍历所有实体
        const dist = e.position.distance(pos)//计算作用点与当前实体的距离
        if (dist <= radius) {//当距离小于等于有效作用半径
            fn(e, dist)//传递当前实体和距离到回调函数并执行
        }
    }
}

async function killBox(pos, size, fn) { //盒状AOE
    //搜索包围盒内的所有实体
    const entities = world.searchBox({
        lo: [pos.x - size, pos.y - size, pos.z - size], //包围盒下边界
        hi: [pos.x + size, pos.y + size, pos.z + size], //包围盒上边界
    })

    for (const e of entities) { //遍历所有找到的实体
        fn(e)
    }
}

async function makeDamage(e, dmg, color) {
    e.hurt(Math.max(1, dmg)) //max用于防止负数伤害

    e.meshColor.copy(color) //当前实体变色
    await sleep(500)
    e.meshColor.set(1, 1, 1, 1) //恢复正常颜色
}

const RED = new Box3RGBAColor(1, 0, 0, 1)
const GREEN = new Box3RGBAColor(0, 1, 0, 1)
const BLUE = new Box3RGBAColor(0, 0, 1, 1)
world.onPress(({ entity, button, raycast }) => {
    if (button === Box3ButtonType.CROUCH) { //下蹲键触发自身球状AOE
        const range = 8//AOE有效作用半径
        killZone(entity.position, range, async (e, dist) => {
            if (e === entity) return//如果当前实体是AOE施放者, 就不继续执行, 避免伤到自己
            const ratio = (range - dist) / range //计算距离百分比, 离得越近ratio越趋向1, 离得越远ratio越趋向0
            makeDamage(e, 100 * ratio, RED)
        })
    }
    else if (button === Box3ButtonType.ACTION0) { //左键触发远距离球状AOE
        const range = 8//AOE有效作用半径
        killZone(raycast.hitPosition, range, async (e, dist) => {
            if (e === entity) return//如果当前实体是AOE施放者, 就不继续执行, 避免伤到自己
            const ratio = (range - dist) / range //计算距离百分比, 离得越近ratio越趋向1, 离得越远ratio越趋向0
            makeDamage(e, 100 * ratio, GREEN)
        })
    }
    else if (button === Box3ButtonType.ACTION1) { //右键触发远距离盒状AOE
        const size = 7 //AOE盒的大小
        killBox(raycast.hitPosition, size, (e) => {
            if (e === entity) return//如果当前实体是AOE施放者, 就不继续执行, 避免伤到自己
            makeDamage(e, 20, BLUE)
        })
    }
})
            </code>
        </pre>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="panel panel-default">
                                        <div class="panel-heading">
                                            <a class="panel-title collapsed" data-toggle="collapse"
                                                data-parent="#panel-586155" href="#panel-element-7">弹跳装置和加速器</a>
                                        </div>
                                        <div id="panel-element-7" class="panel-collapse collapse">
                                            <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
                                                <pre>
            <code class="language-js">
             /**
 * !info {Project} -来自(shequ.codemao.cn/community/373142)@吉吉喵
 * 作为岛上最受欢迎的游戏类型
 * 跑酷是很多萌新都会选择的玩法
 * 除了存档功能之外
 * 吉吉喵今天再教你两招
 * 让你的跑酷地图与众不同！
 */



// 弹射板代码：
const pad = world.querySelector('#弹射跳板-1')
pad.onEntityContact(({ other, axis }) => {
    if (axis.y === -1) { // 如果是往下踩
        other.velocity.y = 2 // 设置玩家的瞬时y轴速度为2
    }
})



// 加速带代码：
const speedBump = world.querySelector('#加速带-1')
speedBump.onEntityContact(async ({ other }) => {
    if (other.isPlayer) {
        if (other.speedUp) {
            return //如果已经在加速中就不再加速
        }
        other.speedUp = true

        //记住正常的速度
        const oldSpeed = other.player.runSpeed
        const oldAccel = other.player.runAcceleration

        //双倍速度
        other.player.runSpeed *= 2
        other.player.runAcceleration *= 2

        await sleep(1000) // 等待一秒

        //恢复正常速度
        other.player.runSpeed = oldSpeed
        other.player.runAcceleration = oldAccel

        other.speedUp = false
    }
})
            </code>
        </pre>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="panel panel-default">
                                        <div class="panel-heading">
                                            <a class="panel-title collapsed" data-toggle="collapse"
                                                data-parent="#panel-586155" href="#panel-element-8">点击建造或者摧毁方块</a>
                                        </div>
                                        <div id="panel-element-8" class="panel-collapse collapse">
                                            <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
                                                <pre>
            <code class="language-js">
              /**
 * !info {Project} -来自(shequ.codemao.cn/community/368401)@吉吉喵
 * -生成山丘的代码-
 */



// 1.点击鼠标摧毁方块

world.onPlayerJoin(({ entity }) => {
    entity.player.enable3DCursor = true // 开启方块光标
})

world.onPress(({ raycast, button }) => {
    if (button === Box3ButtonType.ACTION0) {
        const pos = raycast.voxelIndex // 射线指到的方块位置
        voxels.setVoxel(pos.x, pos.y, pos.z, '')
    }
})



// 2.点击鼠标建造方块

world.onPlayerJoin(({ entity }) => {
    entity.player.enable3DCursor = true // 开启方块光标
})

world.onPress(({ raycast, button }) => {
    if (button === Box3ButtonType.ACTION0) {
        const pos = raycast.voxelIndex.add(raycast.normal) // 射线指到的方块位置加上被选中的面的法线向量
        voxels.setVoxel(pos.x, pos.y, pos.z, 'stone')
    }
})



// 3.点击鼠标切换方块

const voxelList = ['stone', 'dirt', 'grass', 'lava01'] // 可选方块

world.onPlayerJoin(({ entity }) => {
    entity.selected = 0 // 当前选定方块的序号
    entity.player.enable3DCursor = true // 开启方块光标
})

world.onPress(({ entity, raycast, button }) => {
    if (button === Box3ButtonType.ACTION0) {
        const vox = voxelList[entity.selected]
        const pos = raycast.voxelIndex.add(raycast.normal) // 射线指到的方块位置加上被选中的面的法线向量
        voxels.setVoxel(pos.x, pos.y, pos.z, vox)
    }
    else if (button === Box3ButtonType.ACTION1) {
        entity.selected = (entity.selected + 1) % voxelList.length
        const vox = voxelList[entity.selected]
        entity.player.directMessage(`当前选定"${vox}"`)
    }
})



// 3.点击鼠标切换方块

world.onPlayerJoin(({ entity }) => {
    entity.selected = 0 // 当前选定方块的序号
    entity.player.enable3DCursor = true // 开启方块光标
})

world.onPress(({ entity, raycast, button }) => {
    if (button === Box3ButtonType.ACTION0) {
        const vox = voxelList[entity.selected]
        const pos = raycast.voxelIndex.add(raycast.normal) // 射线指到的方块位置加上被选中的面的法线向量
        voxels.setVoxel(pos.x, pos.y, pos.z, vox)
    }
    else if (button === Box3ButtonType.ACTION1) {
        entity.selected = (entity.selected + 1) % voxelList.length
        const vox = voxelList[entity.selected]
        entity.player.directMessage(`当前选定"${vox}"`)
    }
})
            </code>
        </pre>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="panel panel-default">
                                        <div class="panel-heading">
                                            <a class="panel-title collapsed" data-toggle="collapse"
                                                data-parent="#panel-586155" href="#panel-element-9">多重对话之术</a>
                                        </div>
                                        <div id="panel-element-9" class="panel-collapse collapse">
                                            <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
                                                <pre>
            <code class="language-js">
              /**
 * !info {Project} -来自(shequ.codemao.cn/community/437424)@(恶.管)tiger666250
 * 多重对话之术！
 * 地图需包含两个npc模型
 * 与A对话（弹窗）后会接到与B对话的任务
 * 在与B对话完成任务后回来和A互动
 * 将会触发不同的对话内容
 */



console.clear()
async function text(entity, title, content) {//将一个text封装成函数，调用时更加的简单
    return await entity.player.dialog({
        type: Box3DialogType.TEXT,//text
        title,//标题
        content//内容
    })
}
//正片开始
for (const npc of world.querySelectorAll('.npc')) {//在地图中找到所有有npc标签的实体
    npc.enableInteract = true;//你可以和npc互动
    npc.interactRadius = 5;//互动范围为5
    npc.interactHint = npc.id//实体名称为模型的id
    if (npc.id == '吉吉喵') {//如果他是吉吉喵
        npc.onInteract(async ({ entity }) => {//判断互动
            if (entity.jq == 1) {//如果剧情变量为1时，应该让吉吉喵给玩家布置任务
                //以下是剧情
                text(entity, '吉吉喵', `${entity.player.name}，我做好了一碗鸡汤，快去给雷电猴吃吧！`)
                text(entity, '吉吉喵', `把鸡汤给了雷电猴后就过来报道哦~`)
                text(entity, '吉吉喵', `任务1：把鸡汤给雷电猴`)
                entity.player.directMessage('你获得了一碗 鸡汤')
                //变量调整，让玩家去找雷电猴
                entity.jq = 2;
            } else if (entity.jq == 2) {//如果剧情变量为2时，吉吉喵没有需要干的事情，但是为了使情节丰富，我加了一句
                text(entity, '吉吉喵', `你任务没有完成，完成后再回来`);
            } else if (entity.jq == 3) {//如果剧情变量为3时，吉吉喵的任务完成了~
                text(entity, '吉吉喵', `啊哈哈哈哈哈哈哈哈哈哈哈哈我的任务完成啦~`);
            }
        })
    }
    if (npc.id == '雷电猴') {//如果他是雷电猴
        npc.onInteract(async ({ entity }) => {//判断互动
            if (entity.jq == 1) {//如果剧情变量为1时，雷电猴不知道发生了什么，为了使情节丰富，我又加了一句
                text(entity, '雷电猴', `hi`)
            } else if (entity.jq == 2) {//如果剧情变量为2时，雷电猴应该要把鸡汤喝了
                //以下是剧情
                text(entity, '雷电猴', `这是吉吉喵给我的鸡汤是吧，我试试，你看喝鸡汤多是一件美事啊~~`);
                text(entity, '雷电猴', `雷电猴喝下了鸡汤`);
                text(entity, '雷电猴', `任务2：回去找吉吉喵报道吧`)
                entity.player.directMessage('你的任务完成了，可以回去报道了')
                //变量调整，让玩家回去报道
                entity.jq = 3;
            } else if (entity.jq == 3) {//如果剧情变量为3时，雷电猴喝完了鸡汤，认为鸡汤味道好极了
                text(entity, '雷电猴', `这鸡汤不咸不淡，味道好极了！`);
            }
        })
    }
}
world.onPlayerJoin(async ({ entity }) => {//如果玩家进入地图，将玩家的剧情变量变成1
    entity.jq = 1;//剧情，用来判断剧情的变量
})
            </code>
        </pre>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="panel panel-default">
                                        <div class="panel-heading">
                                            <a class="panel-title collapsed" data-toggle="collapse"
                                                data-parent="#panel-586155" href="#panel-element-10">放个烟花</a>
                                        </div>
                                        <div id="panel-element-10" class="panel-collapse collapse">
                                            <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
                                                <pre>
            <code class="language-js">
              /**
 * !info {Project} -来自(shequ.codemao.cn/community/374423)@吉吉喵
 * 还记得“挑战32”颁奖典礼上吉吉喵控制的烟花效果吗？
 * 原理很简单：是通过粒子效果实现的
 */



console.clear()

function particleSpread(entity, colorList, scale = 1) {
    entity.particleRate = 550//粒子生成速率
    entity.particleLifetime = 2//粒子存活时间为2秒
    entity.particleColor = colorList//粒子的颜色列表
    entity.particleSize = [15 * scale, 10 * scale, 5 * scale, 2 * scale, scale]//粒子在5个阶段的大小
    entity.particleSizeSpread = 2 * scale//粒子的大小的随机变化幅度
    entity.particleVelocitySpread = [20 * scale, 20 * scale, 20 * scale]//粒子XYZ方向速度的随机变化幅度
    entity.particleAcceleration = [0, -10 * scale, 0]//粒子往下飘落模拟重力效果
}

const YELLOW = new Box3RGBColor(10, 10, 2)//黄
const CYAN = new Box3RGBColor(2, 10, 10)//青
const MAGENTA = new Box3RGBColor(10, 2, 10)//品红
const RED = new Box3RGBColor(10, 2, 2)//红
const GREEN = new Box3RGBColor(2, 10, 2)//绿
const BLUE = new Box3RGBColor(2, 2, 10)//蓝

//各个颜色5个粒子阶段的颜色列表
const ColorList = [
    [YELLOW, YELLOW, YELLOW, YELLOW, YELLOW],
    [CYAN, CYAN, CYAN, CYAN, CYAN],
    [MAGENTA, MAGENTA, MAGENTA, MAGENTA, MAGENTA],
    [RED, RED, RED, RED, RED],
    [GREEN, GREEN, GREEN, GREEN, GREEN],
    [BLUE, BLUE, BLUE, BLUE, BLUE],
]


function randomColor() {
    return ColorList[Math.floor(ColorList.length * Math.random())] //随机选取一个颜色列表
}

const MeshScale = [1 / 16, 1 / 16, 1 / 16] //默认的模型缩放系数
async function particleShoot(entity) {
    const fireball = world.createEntity({
        bounds: [0, 0, 0], // 隐形实体默认大小是1x1x1的方块, 现在把它从方块缩成大小为0x0x0的1个点
        collides: false, // 开启碰撞
        gravity: false, // 不受重力影响
        position: entity.position,
    })

    const color = randomColor()//随机颜色
    particleSpread(fireball, color, 0.3) //粒子大小系数缩到0.3, 形成小火球

    await sleep(100) // 等待0.1秒后升空
    fireball.velocity.set(0, 1, 0) // 火球速度为每秒向上1格

    await sleep(2000) //升空2秒后爆炸

    fireball.velocity.set(0, 0, 0) // 火球停止运动
    particleSpread(fireball, color, 1) // 系数增大到1, 让火球变大

    await sleep(1500) //大火球等待1.5秒后消失
    fireball.destroy()
}

const firework = world.querySelector('#新年烟花-1')
firework.enableInteract = true
firework.interactRadius = 3
firework.onInteract(async () => {
    var n = 3 //每次
    while (n-- > 0) {
        particleShoot(firework)//在"新年烟花-1"实体的位置发射烟花
        await sleep(2000)//每隔2秒射1发
    }
})
            </code>
        </pre>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="panel panel-default">
                                        <div class="panel-heading">
                                            <a class="panel-title collapsed" data-toggle="collapse"
                                                data-parent="#panel-586155" href="#panel-element-11">飞檐走壁</a>
                                        </div>
                                        <div id="panel-element-11" class="panel-collapse collapse">
                                            <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
                                                <pre>
            <code class="language-js">
              /**
 * !info {Project} -来自(shequ.codemao.cn/community/419110)@吉吉喵
 * 虽然阿吉是一只猫
 * 但一直有一个飞檐走壁的梦想
 * 今天这个教程，就是为了让你们化身超级英雄蜘蛛侠
 * 在城市山川间荡着蛛丝冒险～
 * 快来学习吧！
 */



console.clear()

/** --------------生成围墙的代码----------------- */
for (let x = 0; x < 126; x++) {
    for (let y = 9; y < 126; y++) {
        voxels.setVoxel(x, y, 0, 'stone')
        voxels.setVoxel(x, y, 125, 'stone')
    }
}
for (let z = 0; z < 126; z++) {
    for (let y = 9; y < 126; y++) {
        voxels.setVoxel(0, y, z, 'stone')
        voxels.setVoxel(125, y, z, 'stone')
    }
}
/** --------------生成围墙的代码----------------- */


world.onPlayerJoin(({ entity }) => {
    entity.player.onPress(async ({ raycast, button }) => {
        // 点击鼠标左键 发射蛛丝，并飞向蛛丝射中的位置
        if (button == Box3ButtonType.ACTION0) {

            // 首先实现发射蜘蛛丝的效果
            // 并拿到蜘蛛丝的实体做后续操作
            const spiderSilk = fireSpiderSilk(raycast, entity)

            // 使用animate模拟飞行过程中，蛛丝逐渐缩短的效果
            shortenSpiderSilk(raycast, spiderSilk)

            await sleep(1000)

            // 蛛丝开始缩放后，给玩家沿着蛛丝方向的速度，模拟蛛丝拉扯飞行的效果
            firePlayer(raycast, entity)

            // 最后要记得销毁蛛丝，避免卡顿
            await sleep(500)
            spiderSilk.destroy()
        }
    })
})

/** 发射玩家 */
function firePlayer(raycast, entity) {
    // 准心击中位置与玩家位置做向量减法，获得蛛丝的方向向量
    const direction = raycast.hitPosition.sub(entity.position)
    // 给方向向量乘以一个合适的系数，模拟玩家飞出去的效果。y轴速度小一些的原因是避免飞太高
    const velocity = new Box3Vector3(direction.x * 0.15, direction.y * 0.1, direction.z * 0.15)
    entity.velocity = velocity.clone()

    // 小技巧~~如果射中了其他玩家，可以给他一个反方向速度，模拟粘过来的效果
    if (raycast.hitEntity && raycast.hitEntity.isPlayer) {
        raycast.hitEntity.velocity = velocity.scale(-1)
    }
}

/** 蛛丝缩短的效果 */
function shortenSpiderSilk(raycast, spiderSilk) {
    // 飞行过程中，蛛丝变化的属性有：position、meshScale
    // 如果只缩短蛛丝，而不更改蛛丝位置，不能完整模拟出效果
    // 蛛丝初始生成位置
    const startPos = spiderSilk.position
    // 蛛丝在缩短的过程中需要移动到准心击中的位置
    const endPos = raycast.hitPosition
    // 蛛丝初始缩放值
    const initialScale = spiderSilk.meshScale
    // 蛛丝最终需沿x轴缩到最短
    const endScale = new Box3Vector3(0, 1 / 16, 1 / 16)
    const ani = spiderSilk.animate([
        { position: startPos, meshScale: initialScale, duration: 1 },
        { position: endPos, meshScale: endScale, duration: 0 },
    ])


    ani.play({
        duration: 16 * 0.45, // 播放过程0.45秒，如需更改缩放时间，更改这个数值。相应的也需更改玩家的飞行速度
        iterations: 1, // 只播放一次
        direction: Box3AnimationDirection.NORMAL, // 正常播放
    })
}

/** 发射蜘蛛丝 */
function fireSpiderSilk(raycast, entity) {
    // 摧毁准心对准的方块，用来标记击中的位置
    voxels.setVoxel(raycast.voxelIndex.x, raycast.voxelIndex.y, raycast.voxelIndex.z, 0)
    // 准心击中位置与玩家位置做向量减法，获得蛛丝的方向向量
    const direction = raycast.hitPosition.sub(entity.position)
    // 通过射出的方向向量，计算出蛛丝的旋转四元数
    const meshOrientation = getOrientationByVector(direction)
    // 准心击中位置与玩家位置的距离，为蛛丝的长度
    const distance = raycast.hitPosition.distance(entity.position)
    // 1/16 为基准缩放值。蛛丝的设计模型为沿x轴方向设计，且为两个方块长度。因此x轴缩放值为1 / 16 * distance / 2
    const initialScale = new Box3Vector3(1 / 16 * distance / 2, 1 / 16, 1 / 16)
    // 蛛丝的生成位置应为 准心击中位置与玩家位置的向量插值的中心点
    const initialPos = entity.position.lerp(raycast.hitPosition, 0.5)
    // 用各种计算好的数值创建蛛丝
    const spiderSilk = world.createEntity({
        mesh: "mesh/钢丝.vb",
        position: initialPos,
        collides: false,
        gravity: false,
        meshScale: initialScale,
        meshOrientation: meshOrientation
    })
    return spiderSilk
}

// 本示例中用到的钢丝模型为沿着x轴方向设计。因此用的Box3Quaternion(0, 0, 0, 1)四元数去做旋转计算
// 如果大家使用沿其他轴向设计的模型，请使用下面注释的四元数去做旋转计算
const Quat = new Box3Quaternion(0, 0, 0, 1) // 沿x轴方向设计的蛛丝，初始化四元数，用于旋转计算
// const Quat = new Box3Quaternion(0.000, 0.000, -0.707, 0.707) // 沿y轴方向设计的资源用
// const Quat = new Box3Quaternion(0.000, 0.707, 0.000, 0.707) // 沿z轴方向设计的资源用

/** 通过射出的方向向量，计算出蛛丝的旋转四元数 */
function getOrientationByVector(vector3) {
    const src = vector3
    let dx = src.x
    let dy = src.y
    let dz = src.z
    let dist = Math.sqrt(dx * dx + dz * dz)
    const rotx = Math.atan2(dy, dist)
    return Quat.rotateX(rotx).rotateY(Math.atan2(dz, dx))
}
            </code>
        </pre>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="panel panel-default">
                                        <div class="panel-heading">
                                            <a class="panel-title collapsed" data-toggle="collapse"
                                                data-parent="#panel-586155" href="#panel-element-12">分组</a>
                                        </div>
                                        <div id="panel-element-12" class="panel-collapse collapse">
                                            <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
                                                <pre>
            <code class="language-js">
              /**
 * !info {Project} -来自(shequ.codemao.cn/community/379286)@吉吉喵
 * 分组PK是一种常见的多人游戏模式
 * 今天吉吉喵就叫你如何给玩家分组对战～
 */



function joinRed(entity) {
    entity.addTag('red')//加红队标签
    entity.player.color.set(1, 0, 0)//变红
    world.say(`${entity.player.name} 被分配到红队`)
}

function joinBlue(entity) {
    entity.addTag('blue')//加蓝队标签
    entity.player.color.set(0, 0, 1)//变蓝
    world.say(`${entity.player.name} 被分配到蓝队`)
}

world.onPlayerJoin(({ entity }) => {

    const red = world.querySelectorAll('.red') //红队玩家列表
    const blue = world.querySelectorAll('.blue') //蓝队玩家列表
    if (red.length === blue.length) {//如果两队人数相同
        if (Math.random() < 0.5) {//随机加入其中一队
            joinBlue(entity)//加入蓝队
        }
        else {
            joinRed(entity)//加入红队
        }
    }
    else if (red.length > blue.length) {//如果红队人多
        joinBlue(entity)//加入蓝队
    }
    else {
        joinRed(entity)//加入红队
    }

})
            </code>
        </pre>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="panel panel-default">
                                        <div class="panel-heading">
                                            <a class="panel-title collapsed" data-toggle="collapse"
                                                data-parent="#panel-586155" href="#panel-element-13">分组对战</a>
                                        </div>
                                        <div id="panel-element-13" class="panel-collapse collapse">
                                            <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
                                                <pre>
            <code class="language-js">
              /**
 * !info {Project} -来自(shequ.codemao.cn/community/388136)@吉吉喵
 * 给玩家分组对战的进阶版教程来力！
 */



function joinRed(entity) {
    entity.addTag('red')//加红队标签
    entity.player.color.set(1, 0, 0)//变红
    world.say(`${entity.player.name} 被分配到红队`)
    entity.player.spawnPoint.set(5, 10, 64)//设置红队的出生点在地图的一边
}

function joinBlue(entity) {
    entity.addTag('blue')//加蓝队标签
    entity.player.color.set(0, 0, 1)//变蓝
    world.say(`${entity.player.name} 被分配到蓝队`)
    entity.player.spawnPoint.set(122, 10, 64)//设置蓝队的出生点在地图的另一边
}

world.onPlayerJoin(({ entity }) => {

    const red = world.querySelectorAll('.red') //红队玩家列表
    const blue = world.querySelectorAll('.blue') //蓝队玩家列表
    if (red.length === blue.length) {//如果两队人数相同
        if (Math.random() < 0.5) {//随机加入其中一队
            joinBlue(entity)//加入蓝队
        }
        else {
            joinRed(entity)//加入红队
        }
    }
    else if (red.length > blue.length) {//如果红队人多
        joinBlue(entity)//加入蓝队
    }
    else {
        joinRed(entity)//加入红队
    }

    entity.player.forceRespawn() //传送到自己队伍的出生点
    entity.enableDamage = true //允许玩家受伤
    entity.score = 0 //玩家初始得分为0
    entity.onDie(async ({ attacker }) => {
        let attackerTeam = teamName(attacker)//对手的队名
        let myTeam = teamName(entity)//玩家的队名

        world.say(`[${attackerTeam}]${attacker.player.name} 击败了 [${myTeam}]${entity.player.name}`)
        attacker.score += 1 //当玩家被击败时, 给对手加1分

        await sleep(5000) //等待5秒后复活
        entity.player.forceRespawn() //满血回到出生点
    })
})

function teamName(entity) {
    if (entity.hasTag('red')) {//如果有红队标签
        return '红队'
    }
    else if (entity.hasTag('blue')) {//如果有蓝队标签
        return '蓝队'
    }
    return '未知队伍'
}

world.onClick(({ entity, clicker }) => {
    if ( //如果攻击者和被击者在不同的队伍, 则被击者会受伤
        (entity.hasTag('red') && clicker.hasTag('blue')) || //被击者是红队, 攻击者是蓝队
        (entity.hasTag('blue') && clicker.hasTag('red')) //或者 被击者是蓝队, 攻击者是红队
    ) {
        entity.hurt(10, { attacker: clicker }) //被点击者受到10点伤害, 并将点击者传递给onDie事件
    }
})

world.onPress(({ entity, button }) => {
    if (button == Box3ButtonType.ACTION1) { //右键查看自己的分数
        entity.player.dialog({
            type: Box3DialogType.TEXT,
            content: `本回合你击败了${entity.score}个对手`
        })
    }
})
            </code>
        </pre>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="panel panel-default">
                                        <div class="panel-heading">
                                            <a class="panel-title collapsed" data-toggle="collapse"
                                                data-parent="#panel-586155" href="#panel-element-14">氛围倒计时</a>
                                        </div>
                                        <div id="panel-element-14" class="panel-collapse collapse">
                                            <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
                                                <pre>
            <code class="language-js">
              /**
 * !info {Project} -来自(shequ.codemao.cn/community/418160)@吉吉喵
 * 还记得编程猫博物馆颁奖典礼前炫酷的倒计时吗？
 * 氛围感拉满～
 */



console.clear()

/**
 * 字符形状对应的方块点位
 * 值为1，则显示方块
 * 值为0，则不显示方块
 * 以此来拼凑出字符的形状
 */
const charMap = {
    '0': [
        [1, 1, 1],
        [1, 0, 1],
        [1, 0, 1],
        [1, 0, 1],
        [1, 1, 1],
    ],
    '1': [
        [0, 1, 0],
        [0, 1, 0],
        [0, 1, 0],
        [0, 1, 0],
        [0, 1, 0],
    ],
    '2': [
        [1, 1, 1],
        [0, 0, 1],
        [1, 1, 1],
        [1, 0, 0],
        [1, 1, 1],
    ],
    '3': [
        [1, 1, 1],
        [0, 0, 1],
        [1, 1, 1],
        [0, 0, 1],
        [1, 1, 1],
    ],
    '4': [
        [1, 0, 1],
        [1, 0, 1],
        [1, 1, 1],
        [0, 0, 1],
        [0, 0, 1],
    ],
    '5': [
        [1, 1, 1],
        [1, 0, 0],
        [1, 1, 1],
        [0, 0, 1],
        [1, 1, 1],
    ],
    '6': [
        [1, 1, 1],
        [1, 0, 0],
        [1, 1, 1],
        [1, 0, 1],
        [1, 1, 1],
    ],
    '7': [
        [1, 1, 1],
        [0, 0, 1],
        [0, 0, 1],
        [0, 0, 1],
        [0, 0, 1],
    ],
    '8': [
        [1, 1, 1],
        [1, 0, 1],
        [1, 1, 1],
        [1, 0, 1],
        [1, 1, 1],
    ],
    '9': [
        [1, 1, 1],
        [1, 0, 1],
        [1, 1, 1],
        [0, 0, 1],
        [1, 1, 1],
    ],
    ':': [
        [0, 0, 0],
        [0, 1, 0],
        [0, 0, 0],
        [0, 1, 0],
        [0, 0, 0],
    ],
}

/**
 * 渲染一个字符
 * @parame char 需渲染的字符
 * @parame position 字符左上角位置
 */
function renderOneChar(char, position) {
    // 获取字符对应的方块点位，点位数据为二维数组
    const charData = charMap[char]
    // 遍历点位二维数组
    for (let i = 0; i < charData.length; i++) {
        const row = charData[i]
        // 遍历点位第i行
        for (let j = 0; j < row.length; j++) {
            const value = row[j]
            // 每一行方块的x坐标，随着列数增加而增加
            const x = position.x + j
            // 每一行方块的y坐标，随着行数增加而降低
            const y = position.y - i
            // 每一行方块的z坐标相同
            const z = position.z
            if (value == 0) {
                // 值为0，则不显示方块
                voxels.setVoxelId(x, y, z, 0)
            } else {
                voxels.setVoxel(x, y, z, 'red_light')
            }
        }
    }
}

/**-------------测试 renderOneChar 函数---------------- */
renderOneChar('2', new Box3Vector3(20, 20, 20))
/**-------------测试 renderOneChar 函数---------------- */



/**
 * 渲染一个字符串
 * @parame str 需渲染的字符串
 * @parame position 字符串第一个字符的左上角位置
 */
function renderString(str, position) {
    // 遍历每个字符，依次渲染
    for (let i = 0; i < str.length; i++) {
        // 观察charMap可知每个字符占用宽度为3，再加上字符间应有间距,因此每个字符的x要相距4
        const pos = position.add(new Box3Vector3(4 * i, 0, 0))
        renderOneChar(str[i], pos)
    }
}

/**-------------测试 renderString 函数---------------- */
renderString('22', new Box3Vector3(35, 20, 20))
/**-------------测试 renderString 函数---------------- */



/** 获取符合00：00格式的字符串 */
function getTimeStr(time) {
    if (time > 0) {
        if (time >= 10) {
            t = time
        } else {
            // 小于10时，前面补一个0
            t = '0' + time
        }
    } else {
        // 等于0时，用两个0代替
        t = '00'
    }
    return t
}

/**
 * 开始倒计时
 * @parame totalTime  总计时（单位：秒）
 * @parame position 倒计时的左上角位置
 */
async function startCountDown(totalTime, position) {
    let time = totalTime
    // 每隔1秒判断一次，直到时间减为0
    while (time >= 0) {
        // 获得分钟数
        const minute = Math.floor(time / 60)
        // 获得秒数
        const second = time % 60
        // 转化为符合规则的字符串
        const minuteStr = getTimeStr(minute)
        // 转化为符合规则的字符串
        const secondStr = getTimeStr(second)
        // 用":"拼凑出时间字符串
        const timeStr = minuteStr + ':' + secondStr
        // 渲染出时间字符串
        renderString(timeStr, position)
        // 每隔1秒 时间变量减一
        await sleep(1000)
        time--
    }
}

/**-------------测试 startCountDown 函数---------------- */
// 总倒计时 72秒
const totalTime = 72
// 倒计时的左上角位置
const position = new Box3Vector3(55, 20, 20)
startCountDown(totalTime, position)
/**-------------测试 startCountDown 函数---------------- */

            </code>
        </pre>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="panel panel-default">
                                        <div class="panel-heading">
                                            <a class="panel-title collapsed" data-toggle="collapse"
                                                data-parent="#panel-586155" href="#panel-element-15">俯瞰地图</a>
                                        </div>
                                        <div id="panel-element-15" class="panel-collapse collapse">
                                            <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
                                                <pre>
            <code class="language-js">
              /**
 * !info {Project} -来自(shequ.codemao.cn/community/419961)@吉吉喵
 * 当你的地图面积非常大时
 * 如何才能快速看到全景、并定位自己所在的位置？
 * 今天这招，就教你们“登高望远”
 * 俯瞰地图全景：
 */



// 点击鼠标右键（B），弹出对话框，视线变为俯视
world.onPlayerJoin(({ entity }) => {
    entity.player.onPress(async ({ button }) => {
        if (button == Box3ButtonType.ACTION1) {
            // 将摄像机看向地图中心
            const lookTarget = new Box3Vector3(63, 8, 63);

            // 将摄像机的位置置于地图大概中心处，并往上拉升到y轴150处，确保看到完整的地形
            const lookEye = new Box3Vector3(63, 150, 63);

            // lookUp用来调整相机角度，可以使画面上下左右颠倒。默认值是(0,1,0)
            // 由于视线是俯视，需要确保lookUp与相机视线方向不平行,需修改为(1,0,0)或者(0,0,1)
            const lookUp = new Box3Vector3(1, 0, 0)

            entity.player.dialog({
                type: Box3DialogType.TEXT,
                content: `俯视`,
                lookEye: lookEye,
                lookTarget: lookTarget,
                lookUp: lookUp
            })
        }
    })
})



// 实现多个方向的效果
// 我们生成一个浮在空中的立方体,每个面颜色不同，方便实现6个方向的观察测试。
function cube(sx, sy, sz, xsize, ysize, zsize) {
    var xend = sx + xsize
    var yend = sy + ysize
    var zend = sz + zsize
    for (var x = sx; x < xend; x++) {
        for (var y = sy; y < yend; y++) {
            for (var z = sz; z < zend; z++) {
                if (x === sx) {
                    voxels.setVoxel(x, y, z, 'green_light')
                }
                if (x === xend - 1) {
                    voxels.setVoxel(x, y, z, 'red_light')
                }
                if (y === sy) {
                    voxels.setVoxel(x, y, z, 'black')
                }
                if (y === yend - 1) {
                    voxels.setVoxel(x, y, z, 'white_light')
                }
                if (z === sz) {
                    voxels.setVoxel(x, y, z, 'blue_light')
                }
                if (z === zend - 1) {
                    voxels.setVoxel(x, y, z, 'yellow_light')
                }
            }
        }
    }
}

//在{x:50, y:50, z:50} 位置，建造一个长20格，宽20格，高20格的空心立方体
cube(50, 50, 50, 20, 20, 20)



world.onPlayerJoin(({ entity }) => {
    entity.player.onPress(async ({ button }) => {
        if (button == Box3ButtonType.ACTION0) {
            let loop = true
            // 只要不是选择了退出，都反复让用户选择要看的颜色那一面
            while (loop) {
                let sel = await entity.player.dialog({
                    type: Box3DialogType.SELECT,
                    content: '选择要看的颜色',
                    options: ['黄色', '蓝色', '红色', '绿色', '白色', '黑色', '退出']
                })

                if (sel) {
                    // 初始化相机参数
                    const lookTarget = new Box3Vector3(0, 0, 0)
                    const lookEye = new Box3Vector3(0, 0, 0)
                    const lookUp = new Box3Vector3(0, 1, 0)


                    // 根据选择的颜色，将lookTarget设置为所看颜色面的中心点坐标
                    // 并将lookEye沿着视线拉远距离

                    // z轴视线
                    if (sel.value == '黄色') {
                        lookTarget.set(60, 60, 50)
                        lookEye.set(60, 60, 180)
                    }
                    // z轴视线
                    if (sel.value == '蓝色') {
                        lookTarget.set(60, 60, 50)
                        lookEye.set(60, 60, -60)
                    }
                    // x轴视线
                    if (sel.value == '红色') {
                        lookTarget.set(50, 60, 60)
                        lookEye.set(180, 60, 60)
                    }
                    // x轴视线
                    if (sel.value == '绿色') {
                        lookTarget.set(50, 60, 60)
                        lookEye.set(-60, 60, 60)
                    }
                    // y轴视线俯视
                    if (sel.value == '白色') {
                        lookTarget.set(60, 70, 60)
                        lookEye.set(60, 150, 60)
                        // 相机lookUp与相机视线方向不能平行，需修改为(1,0,0)或者(0,0,1)
                        lookUp.set(1, 0, 0)
                    }
                    // y轴视线仰视
                    if (sel.value == '黑色') {
                        lookTarget.set(60, 70, 60)
                        lookEye.set(60, 10, 60)
                        // 相机lookUp与相机视线方向不能平行，需修改为(1,0,0)或者(0,0,1)
                        lookUp.set(0, 0, 1)
                    }
                    if (sel.value == '退出') {
                        // 用户选择退出，则退出选择界面
                        loop = false
                    } else {

                        // 使用用户选择所对应的参数来设置相机，并弹出对话框
                        await entity.player.dialog({
                            type: Box3DialogType.TEXT,
                            content: `看向${sel.value}面`,
                            lookEye: lookEye,
                            lookTarget: lookTarget,
                            lookUp: lookUp
                        })
                    }
                }
            }
        }
    })
})
            </code>
        </pre>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="panel panel-default">
                                        <div class="panel-heading">
                                            <a class="panel-title collapsed" data-toggle="collapse"
                                                data-parent="#panel-586155" href="#panel-element-16">可穿戴设备</a>
                                        </div>
                                        <div id="panel-element-16" class="panel-collapse collapse">
                                            <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
                                                <pre>
            <code class="language-js">
              /**
 * !info {Project} -来自(shequ.codemao.cn/community/374598)@吉吉喵
 * 皮肤虽然有限
 * 但可穿戴装备是无限的！
 * 学会这项技能
 * 你就是岛上最靓的崽～
 */



world.onPlayerJoin(({entity}) => {
    entity.player.addWearable({
        bodyPart: Box3BodyPart.HEAD,
        mesh: 'mesh/三级盔.vb',
        orientation: new Box3Quaternion(0,1,0,0).rotateY(-Math.PI/2),
        offset: new Box3Vector3(0,0.4,0.1),
    });
    entity.player.addWearable({
        bodyPart: Box3BodyPart.RIGHT_HAND,
        mesh: 'mesh/95式 [精美].vb',
        orientation: new Box3Quaternion(0,1,0,0).rotateY(Math.PI),
        offset: new Box3Vector3(-0.05,-0.1,0.5),
        scale: Box3Vector3 = new Box3Vector3(0.3, 0.3, 0.3),
    });
});

            </code>
        </pre>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="panel panel-default">
                                        <div class="panel-heading">
                                            <a class="panel-title collapsed" data-toggle="collapse"
                                                data-parent="#panel-586155" href="#panel-element-17">满足人数开始游戏</a>
                                        </div>
                                        <div id="panel-element-17" class="panel-collapse collapse">
                                            <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
                                                <pre>
            <code class="language-js">
              /**
 * !info {Project} -来自(shequ.codemao.cn/community/439092)@BZIClaw
 * 实现的效果是当地图内玩家人数满足3人时游戏开局！
 */



console.clear();  // 清空控制台

world.onPlayerJoin(({ entity }) => {  // 当实体进入地图
    if (entity.isPlayer) {  // 如果实体是一个玩家
        entity.addTag('NotInGame');  // 添加标签 “不在游戏中”
        if (world.querySelectorAll('player').length >= 3) {  // 如果玩家的数量 >= 3 则开始游戏
            for (const c of world.querySelectorAll('.NotInGame')) {  // 让所有不在游戏中的玩家传送到 “游戏区”
                c.player.spawnPoint.set(60, 15, 76);  // 重新重生点
                c.player.forceRespawn();  // 强制传送
                c.removeTag('NotInGame');  // 删掉标签 “不在游戏中”
                c.player.dialog({  // 对话框
                    type: Box3DialogType.TEXT,
                    title: `欢迎`,
                    content: `人数已超过 3 人，可进入游戏~~`
                })
            }
        } 
        else {  // 如果玩家人数不够，就执行这些代码
            entity.player.spawnPoint.set(41, 37, 44);  // 在上层 “休息区” 出生
            entity.player.forceRespawn();  // 强制传送（重生）
            entity.player.dialog({  // 发送对话框
                type: Box3DialogType.TEXT,
                title: `欢迎`,
                content: `目前人数未达到 3 人，请等待其他玩家进入~~`
            })
        }
    }
});
            </code>
        </pre>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="panel panel-default">
                                        <div class="panel-heading">
                                            <a class="panel-title collapsed" data-toggle="collapse"
                                                data-parent="#panel-586155" href="#panel-element-18">排行榜</a>
                                        </div>
                                        <div id="panel-element-18" class="panel-collapse collapse">
                                            <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
                                                <pre>
            <code class="language-js">
              /**
 * !info {Project} -来自(shequ.codemao.cn/community/415223)@吉吉喵
 * 圣诞创作节下半场已经在昨天开启
 * “第一才有圣诞礼物”这个主题让你想到什么呢？
 * 没错，就是排行榜！
 * 加入这个功能，一定会让你的参赛作品赢面更大～
 */



// 当玩家进入游戏时
world.onPlayerJoin(({ entity }) => {
    // 设置刚进入游戏的玩家持有金币(coin)数量为0
    entity.player.coin = 0
    // 当玩家按下按键时，触发交互
    entity.player.onPress(({ button }) => {
        if (button === Box3ButtonType.ACTION0) {
            entity.player.dialog({
                type: Box3DialogType.TEXT,
                title: "金币排行榜",
                content: dialogContent(),
            })
        }
    })
});

// 找到世界中的"AT M"机器模型
const atm = world.querySelector(`#A喵`)
// 设置AT M机器可互动
atm.enableInteract = true
// 设置AT M机器互动距离为5
atm.interactRadius = 5;

// 监听世界中的互动事件
world.onInteract(({ entity, targetEntity }) => {
    // 判断被"互动"的实体，
    if (targetEntity.id === "A喵") {
        entity.player.coin = entity.player.coin + 1;
        world.say(`${entity.player.name}获得了1金币！`);
    }
})

// 对话框内容
function dialogContent() {
    // 首先获取当前世界中的所有玩家
    const allPlayerEntities = world.querySelectorAll('player');
    // 然后将所有的玩家进行排序，排序的规则是按照玩家持有的金币数量降序
    const sortedPlayerEntities = allPlayerEntities.sort((a, b)=>  b.player.coin - a.player.coin);
    
    
    // 接下来，我们将在排行榜上以: xxx 有 yyy 个金币 的格式展示，并且每一条信息换一行显示！

        // 首先声明一个content字符串，一会用来保存每一个玩家的信息
        let content = "";
    // 在这里需要做一个循环遍历，将刚才得到的有序的玩家数组遍历一遍
    for(const entity of sortedPlayerEntities ) {
        // 在遍历的过程中，每一次遍历，我们拿到当前的实体(entity)，
        // 将实体上的玩家名字(player.name)以及玩家金币数量(player.coin)拼接成排行榜上的一行信息
        // 这样就得到: xxx 有 yyy 个金币 的格式啦
        // 我们在这个文字的末尾加一个\n, 这样我们就能实现换行的效果
        // 紧接着，再把这行信息加上content，这样做是为了把每一个玩家的排行榜信息拼接起来，保存到content中
        content = content + `${entity.player.name}有${entity.player.coin}个金币\n`
    }
    // 最后，把得到的完整的带有玩家名称和金币数量，并且会换行的排行榜数据(content)返回出去
    return content
}
            </code>
        </pre>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="panel panel-default">
                                        <div class="panel-heading">
                                            <a class="panel-title collapsed" data-toggle="collapse"
                                                data-parent="#panel-586155" href="#panel-element-19">区域范围攻击</a>
                                        </div>
                                        <div id="panel-element-19" class="panel-collapse collapse">
                                            <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
                                                <pre>
            <code class="language-js">
              /**
 * !info {Project} -来自(shequ.codemao.cn/community/433216)@可乐OωO
 * 区域范围攻击
 */



console.clear(); //清空控制台信息
const Quat = new Box3Quaternion(0, 0, 0, 1); //初始化四元数，用于旋转
const e = world.querySelector('#炮台'); //获取炮台实体

world.onPlayerJoin(({ entity }) => { //当玩家进入时
    entity.position.set(32, 13, 32); //设置玩家的坐标为 { x: 32, y: 13, z: 32 }
    entity.player.spawnPoint.copy(entity.position); //设置玩家的重生点为位置，也就是 { x: 32, y: 13, z: 32 }
    entity.enableDamage = true; //让玩家允许受到伤害
});

const zone = world.addZone({ //添加一个炮台检测的区域
    selector: 'player', //区域内的物体搜索条件，这里为玩家
    bounds: { //指定检测区域
        lo: e.position.sub({ x: 15, y: 2, z: 15 }), //最低点，这里用位置的sub方法来实现一个位置减去另一个位置的功能
        hi: e.position.add({ x: 15, y: 5, z: 15 }), //最高点，这里用位置的add方法来实现一个位置加上另一个位置的功能
    },
});

zone.onEnter(({ entity }) => { //如果炮台检测的区域进入了玩家
    entity.interval = setInterval(async () => { //每2秒执行一次，把这个程序放在entity.interval中
        if (zone.entities().includes(entity)) { //如果玩家在这个区域里
            let direction = entity.position.sub(e.position); //用位置的sub方法算出方向
            let face = direction.clone(); //用clone函数复制一个一样的位置对象
            let d = Quat.rotateY(Math.atan2(face.z, face.x)); //用初始化四元数的rotateY方法来旋转Y轴，用atan2函数来计算旋转弧度，这样我们就得到了一个玩家方向的四元数
            e.meshOrientation = d; //设置子弹的旋转值为玩家方向

            let bullet = world.createEntity({ //创建一个子弹实体
                mesh: 'mesh/子弹.vb', //模型为子弹模型
                meshScale: [1/16, 1/16, 1/16], //大小为默认大小，[1/16, 1/16, 1/16]
                collides: true, //开启碰撞
                gravity: false, //不受重力影响
                position: e.position, //在玩家的位置生成子弹
                velocity: face.scale(0.15), //子弹的初速度是玩家方向，因为速度太快了，所以要用位置的scale方法来把xyz各乘上0.15
                meshOrientation: d.rotateY(Math.PI / 2), //子弹的头指向玩家，这里还需要用四元数的rotateY方法来旋转90度
            });

            bullet.onEntityContact(({ other }) => { //每当子弹碰到另一个实体
                if (other.hp > 0) { //如果这个实体的血量大于0
                    other.hurt(10, { //被碰实体受10点伤害
                        damageType: '炮台的子弹', //伤害类型设为“炮台的子弹” 
                    });
                    bullet.destroy(); //攻击之后子弹消失，防止重复攻击
                }
            });

            await sleep(1500); //等1.5秒后
            if (!bullet.destroyed) { //如果这个子弹还没有清除
                bullet.destroy(); //清除子弹，防止子弹数量太多超过服务器负载
            }
        }
    }, 2000);
});

zone.onLeave(({ entity }) => {
    if (entity.interval) clearInterval(entity.interval); //如果entity.interval这个程序存在，把每2秒执行一次的子弹程序取消，防止多个子弹程序一起发生
});

world.onDie(async ({ entity, damageType }) => { //当有玩家S亡时
    if (entity.interval) clearInterval(entity.interval); //如果entity.interval这个程序存在，把每2秒执行一次的子弹程序取消，防止多个子弹程序一起发生
    while (1) { //无限循环，防止玩家点“×”
        let respawnDialog = await entity.player.dialog({ //该玩家弹出一个对话框
            type: Box3DialogType.SELECT, //类型为选择对话框
            title: '死亡提示', //将对话框的标题设为“死亡提示”
            content: `你被 ${damageType} 击杀了`, //将对话框的内容设为一个模板字符串，拼接方式为 '你被' + damageType + '击杀了'
            options: ['重生'], //对话框的选项只有一个，就是“重生”
        });

        if (respawnDialog) { //如果玩家点击了选项（因为选项只有一个，所以这行代码的意思还可以是“如果玩家点击了‘重生’”）
            entity.player.forceRespawn(); //让玩家重生
            break; //退出无限循环
        } //这里不用判断“如果玩家没有点击选项”了，因为这是无限循环，如果不点击选项就没有break，自然就直接进行下一轮循环（重新弹出一遍对话框）了
    }
});
            </code>
        </pre>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="panel panel-default">
                                        <div class="panel-heading">
                                            <a class="panel-title collapsed" data-toggle="collapse"
                                                data-parent="#panel-586155" href="#panel-element-20">让模型几秒钟后消失</a>
                                        </div>
                                        <div id="panel-element-20" class="panel-collapse collapse">
                                            <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
                                                <pre>
            <code class="language-js">
              /**
 * !info {Project} -来自(shequ.codemao.cn/community/363908)@吉吉喵
 * 只需要下面这串神奇的代码
 * 就能让模型在固定的时间消失！
 */



async function hideAfter3Sec(entity) {
    await sleep(3000)
    entity.meshInvisible = true
  }
  
  hideAfter3Sec(world.querySelector('#灯笼'))
            </code>
        </pre>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="panel panel-default">
                                        <div class="panel-heading">
                                            <a class="panel-title collapsed" data-toggle="collapse"
                                                data-parent="#panel-586155" href="#panel-element-21">山丘生成</a>
                                        </div>
                                        <div id="panel-element-21" class="panel-collapse collapse">
                                            <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
                                                <pre>
            <code class="language-js">
              /**
 * !info {Project} -来自(shequ.codemao.cn/community/362114)@吉吉喵
 * -生成山丘的代码-
 */



function cylinder(cx, cy, cz, vox, radius, height) {
    var xend = cx + radius;
    var yend = cy + height;
    var zend = cz + radius;
    for (var x = cx - radius; x <= xend; x++) {
        for (var z = cz - radius; z <= zend; z++) {
            var dx = x - cx;
            var dz = z - cz;
            if (Math.round(Math.sqrt(dx * dx + dz * dz)) <= radius) {
                for (var y = cy; y < yend; y++) {
                    voxels.setVoxel(x, y, z, vox);
                }
            }
        }
    }
}

for (var i = 0; i < 300; i++) { /* 300个随机圆柱体构成场景 */
    let x = Math.random() * 125; /* x坐标 */
    let z = Math.random() * 125; /* z坐标 */
    let h = Math.random() * 4; /* 高 0~3.9999 */
    let r = 2 + Math.random() * 5; /* 半径 2~6.9999 */
    cylinder(x, 9, z, 'dirt', r, h);
}

for (var y = 9; y < 13; y++) { /* 扫描9~12层的格子 */
    for (var x = 0; x < 127; x++) {
        for (var z = 0; z < 127; z++) {
            /* 如果当前格子不为空而它上面那格是空的, 则表示它是复杂地形的表面 */
            if (voxels.getVoxel(x, y, z) != 0 && voxels.getVoxel(x, y + 1, z) == 0) {
                voxels.setVoxel(x, y, z, 'grass'); /* 土块替换成草地 */
            }
        }
    }
}
            </code>
        </pre>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="panel panel-default">
                                        <div class="panel-heading">
                                            <a class="panel-title collapsed" data-toggle="collapse"
                                                data-parent="#panel-586155" href="#panel-element-22">设置进阶版复活点</a>
                                        </div>
                                        <div id="panel-element-22" class="panel-collapse collapse">
                                            <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
                                                <pre>
            <code class="language-js">
              /**
 * !info {Project} -来自(shequ.codemao.cn/community/416346)@吉吉喵
 * 跑酷、pvp游戏必备的小技巧来啦！
 * 学会这三种进阶版的复活点写法
 * 基本上就能驾驭大部分的地图玩法了～
 */



// 获取场景里的复活点模型，命名为respawnPoint
// 具体模型可以用任意你喜欢的模型替换，名称也可以替换成你想要的命名
const respawnPoint = world.querySelector(`#复活点`)

// 监听方块与实体的碰撞
world.onVoxelContact(({entity, voxel})=> {
    // 将方块id转换名称
    const voxelName = voxels.name(voxel);
    // 如果方块名称是熔岩
    if (voxelName === 'lava02'){
        // 使实体受到100点伤害
        // 目的是为了直接触发实体的'onDie'事件
        //  *这里为了方便演示，将伤害值直接调到生命值(hp)的上限100点，
        //   具体调到多少点可以自行设置，只要玩家累计受到100点伤害就会触发entity的'onDie'事件
        entity.hurt(100)
    }
})

// 当玩家进入地图时
world.onPlayerJoin(({ entity }) => {
    // 首先要开启enableDamage(允许伤害)，如果不设置为true的话，玩家是不会受到伤害的！
    entity.enableDamage = true
    // 给玩家的'onDie'事件添加处理的逻辑
    // 'onDie'事件会在玩家的生命值(hp)减少到0及以下时触发
    entity.onDie(() => {
        // 设置复活点的主要API: entity.player.spawnPoint

        // 1.在指定位置复活。
        // 复活点设置为世界里的'复活点模型'的坐标(position)
        // 当角色复活的时候就会出现在'复活点模型'的位置上
        // -------------------------打开下面一行注释测试效果，同时给2&3的代码注释掉---------------------------------
        entity.player.spawnPoint = respawnPoint.position.clone();
        // -------------------------打开上面一行注释测试效果，同时给2&3的代码注释掉---------------------------------

        // 2.在指定区域复活
        // const xPos = 72 + Math.random() * 5
        // const zPos = 63 + Math.random() * 5
        // entity.player.spawnPoint = new Box3Vector3(xPos, 15, zPos);


        // 3.在随机区域复活
        // const xPos = 0 + Math.random() * 126
        // const zPos = 0 + Math.random() * 126
        // entity.player.spawnPoint = new Box3Vector3(xPos, 15, zPos);

        // 设置好复活点之后，记得调用forceRespawn() API
        // 这样就可以强制玩家复活到上面设置好的位置了
        entity.player.forceRespawn()
    })
})
            </code>
        </pre>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="panel panel-default">
                                        <div class="panel-heading">
                                            <a class="panel-title collapsed" data-toggle="collapse"
                                                data-parent="#panel-586155" href="#panel-element-23">生成随机数</a>
                                        </div>
                                        <div id="panel-element-23" class="panel-collapse collapse">
                                            <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
                                                <pre>
            <code class="language-js">
              /**
 * !info {Project} -来自(shequ.codemao.cn/community/364404)@吉吉喵
 * 随机生成小鸡
 */



(Math.random()*20,11,Math.random()*20)
            </code>
        </pre>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="panel panel-default">
                                        <div class="panel-heading">
                                            <a class="panel-title collapsed" data-toggle="collapse"
                                                data-parent="#panel-586155" href="#panel-element-24">天气变化</a>
                                        </div>
                                        <div id="panel-element-24" class="panel-collapse collapse">
                                            <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
                                                <pre>
            <code class="language-js">
              /**
 * !info {Project} -来自(shequ.codemao.cn/community/413663)@吉吉喵
 * 久违的小技巧教程来也！
 * 今天带来的是一个非常简单的小教程：
 * 让每一天都随机出现不同的天气
 * 能够很好的配合地图场景需要
 * 非常实用哦
 */



//在左侧工具栏点击 场景->全局特效 打开"飘雪"才能使下雪代码生效
world.snowTexture = 'snow/snow.part'



async function init() {

    while (true) {//无限循环
        if (Math.random() < 0.5) {
            world.rainDensity = 0//停雨
        }
        else {
            world.rainDensity = 0.5//下雨
        }

        if (Math.random() < 0.5) {
            world.snowDensity = 0//停雪
        }
        else {
            world.snowDensity = 0.1//下雪
        }

        if (Math.random() < 0.5) {//停雾
            world.fogUnifor喵ensity = 0
        }
        else {//起雾
            world.fogUnifor喵ensity = 0.1
        }

        world.sunPhase = 0.25 //白天
        await sleep(5000)//等待5000毫秒

        world.sunPhase = 0.75 //黑夜
        await sleep(10000)//等待10000毫秒
      }
}

init()
            </code>
        </pre>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="panel-group" id="panels-1">
            <div class="panel panel-default">
                <div class="panel-heading">
                    <a class="panel-title collapsed" data-toggle="collapse" data-parent="#panels-1"
                        href="#panel-element-MAIN-2">模板代码</a>
                </div>
                <div id="panel-element-MAIN-2" class="panel-collapse collapse">
                    <div class="panel-body">
                        <blockquote>
                            <h2>模板代码</h2>
                        </blockquote>
                        <div class="panel panel-default">
                            <div class="panel-heading">
                                <a class="panel-title collapsed" data-toggle="collapse" data-parent="#panel-586155"
                                    href="#panel-element1-1">打字机</a>
                            </div>
                            <div id="panel-element1-1" class="panel-collapse collapse">
                                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
                                    <pre>
            <code class="language-js">
                /**
 * !info {Project} -来自网络
 * 打字机.js
 */


world.onVoxelContact(({ x, y, z, voxel }) => {
    const voxelName = voxels.name(voxel);
    if (voxelName === 'rock') {
        voxels.setVoxel(46, 11, 52, 'lantern_02');
    }
});

async function change() {
    while (true) {
        voxels.setVoxel(157, 43, 60, 'grass')
        voxels.setVoxel(157, 43, 61, 'grass')
        voxels.setVoxel(157, 43, 62, 'grass')
        voxels.setVoxel(157, 43, 63, 'grass')
        await sleep(5000)
        voxels.setVoxel(157, 43, 60, 'lantern_01')
        voxels.setVoxel(157, 43, 61, 'lantern_01')
        voxels.setVoxel(157, 43, 62, 'lantern_01')
        voxels.setVoxel(157, 43, 63, 'lantern_01')
        await sleep(5000)
    }
}change();

console.clear()

/**
 * 字符形状对应的方块点位
 * 值为1，则显示方块
 * 值为0，则不显示方块
 * 以此来拼凑出字符的形状
 */
const charMap = {
    '0': [
        [1, 1, 1],
        [1, 0, 1],
        [1, 0, 1],
        [1, 0, 1],
        [1, 1, 1],
    ],
    '1': [
        [0, 1, 0],
        [0, 1, 0],
        [0, 1, 0],
        [0, 1, 0],
        [0, 1, 0],
    ],
    '2': [
        [1, 1, 1],
        [0, 0, 1],
        [1, 1, 1],
        [1, 0, 0],
        [1, 1, 1],
    ],
    '3': [
        [1, 1, 1],
        [0, 0, 1],
        [1, 1, 1],
        [0, 0, 1],
        [1, 1, 1],
    ],
    '4': [
        [1, 0, 1],
        [1, 0, 1],
        [1, 1, 1],
        [0, 0, 1],
        [0, 0, 1],
    ],
    '5': [
        [1, 1, 1],
        [1, 0, 0],
        [1, 1, 1],
        [0, 0, 1],
        [1, 1, 1],
    ],
    '6': [
        [1, 1, 1],
        [1, 0, 0],
        [1, 1, 1],
        [1, 0, 1],
        [1, 1, 1],
    ],
    '7': [
        [1, 1, 1],
        [0, 0, 1],
        [0, 0, 1],
        [0, 0, 1],
        [0, 0, 1],
    ],
    '8': [
        [1, 1, 1],
        [1, 0, 1],
        [1, 1, 1],
        [1, 0, 1],
        [1, 1, 1],
    ],
    '9': [
        [1, 1, 1],
        [1, 0, 1],
        [1, 1, 1],
        [0, 0, 1],
        [1, 1, 1],
    ],
    ':': [
        [0, 0, 0],
        [0, 1, 0],
        [0, 0, 0],
        [0, 1, 0],
        [0, 0, 0],
    ],
}

/**
 * 渲染一个字符
 * @parame char 需渲染的字符
 * @parame position 字符左上角位置
 */
function renderOneChar(char, position) {
    // 获取字符对应的方块点位，点位数据为二维数组
    const charData = charMap[char]
    // 遍历点位二维数组
    for (let i = 0; i < charData.length; i++) {
        const row = charData[i]
        // 遍历点位第i行
        for (let j = 0; j < row.length; j++) {
            const value = row[j]
            // 每一行方块的x坐标，随着列数增加而增加
            const x = position.x + j
            // 每一行方块的y坐标，随着行数增加而降低
            const y = position.y - i
            // 每一行方块的z坐标相同
            const z = position.z
            if (value == 0) {
                // 值为0，则不显示方块
                voxels.setVoxelId(x, y, z, 0)
            } else {
                voxels.setVoxel(x, y, z, 'red_light')
            }
        }
    }
}

/**------测试 renderOneChar 函数-------- */
renderOneChar('2', new Box3Vector3(20, 20, 20))
/**------测试 renderOneChar 函数-------- */


/**
 * 渲染一个字符串
 * @parame str 需渲染的字符串
 * @parame position 字符串第一个字符的左上角位置
 */
function renderString(str, position) {
    // 遍历每个字符，依次渲染
    for (let i = 0; i < str.length; i++) {
        // 观察charMap可知每个字符占用宽度为3，再加上字符间应有间距,因此每个字符的x要相距4
        const pos = position.add(new Box3Vector3(4 * i, 0, 0))
        renderOneChar(str[i], pos)
    }
}

/**------测试 renderString 函数-------- */
renderString('22', new Box3Vector3(35, 20, 20))
/**------测试 renderString 函数-------- */



/** 获取符合00：00格式的字符串 */
function getTimeStr(time) {
    if (time > 0) {
        if (time >= 10) {
            t = time
        } else {
            // 小于10时，前面补一个0
            t = '0' + time
        }
    } else {
        // 等于0时，用两个0代替
        t = '00'
    }
    return t
}

/**
 * 开始倒计时
 * @parame totalTime  总计时（单位：秒）
 * @parame position 倒计时的左上角位置
 */
async function startCountDown(totalTime, position) {
    let time = totalTime
    // 每隔1秒判断一次，直到时间减为0
    while (time >= 0) {
        // 获得分钟数
        const minute = Math.floor(time / 60)
        // 获得秒数
        const second = time % 60
        // 转化为符合规则的字符串
        const minuteStr = getTimeStr(minute)
        // 转化为符合规则的字符串
        const secondStr = getTimeStr(second)
        // 用":"拼凑出时间字符串
        const timeStr = minuteStr + ':' + secondStr
        // 渲染出时间字符串
        renderString(timeStr, position)
        // 每隔1秒 时间变量减一
        await sleep(1000)
        time--
    }
}

/**------测试 startCountDown 函数------- */
// 总倒计时 72秒
const totalTime = 72
// 倒计时的左上角位置
const position = new Box3Vector3(55, 20, 20)
startCountDown(totalTime, position)
/**------测试 startCountDown 函数------- */


startCountDown(120, 5, 136)// 坐标，详细自行调整
async function BOOM() {
    world.sunPhase = 0.8
    const Quat = new Box3Quaternion(0, 0, 0, 1) //默认的旋转状态
    const RED = new Box3RGBColor(0.5, 0, 0) //发光的红色
    await sleep(3000)
    world.say("聚变打击即将来袭！")
    const boom = world.createEntity({
        mesh: 'mesh/核弹.vb',
        meshScale: [1 / 2, 1 / 2, 1 / 2],
        position: [100, 50, 18],
        particleRate: 80, //每秒发出80个粒子
        particleLifetime: 2, //每个粒子存活2秒
        particleColor: [RED, RED, RED, RED, RED], //粒子在5个阶段的颜色都是红色
        particleSize: [10, 10, 10, 10, 10], //粒子在5个阶段的大小都是2
        gravity: false,
    })
    boom.meshOrientation = Quat.rotateY(Math.PI / -2)
    await sleep(5000)
    world.say("核弹即将发射")
    await sleep(3000)
    world.say("倒计时:")
    await sleep(1000)
    boom.meshEmissive = 0.3
    world.say("5")
    await sleep(1000)
    boom.meshEmissive = 0
    world.say("4")
    await sleep(1000)
    boom.meshEmissive = 0.3
    world.say("3")
    await sleep(1000)
    boom.meshEmissive = 0
    world.say("2")
    await sleep(1000)
    boom.meshEmissive = 0.3
    world.say("1")
    for (let i = 0; i < 100; i++) {
        await sleep(50)
        boom.position.x -= 1
    }
    world.say("BOOM！")
    boom.destroy()
    world.sunPhase = 0.25
    await sleep(3000)
    world.say("注意持续辐射伤害！！！")
    world.querySelectorAll("player").forEach(async (e) => {
        while (e.hp > 0) {
            await sleep(1000)
            e.hp -= 1
            console.log(e.hp)
        }
    })
}
async function killBox(pos, size, fn) {
    const entities = world.searchBox({
        lo: [pos.x - size, pos.y - size, pos.z - size],
        hi: [pos.x + size, pos.y + size, pos.z + size],
    })
    for (const e of entities) {
        e.hurt(5)
        fn(e)
    }
}
async function makeDamage(e, dmg, color) {
    //e.meshcolor.copy(color)
    await sleep(500)
    //e.meshcolor.set(1,1,1)
}

const mscale = 1 / 16
const Quat = new Box3Quaternion(0, 0, 0, 1)

function buddyFollow(entity, mesh, y) {
    const buddy = world.createEntity({
        mesh,
        position: entity.position,
        meshScale: [mscale, mscale, mscale],
        gravity: false, //不受重力影响
        fixed: false, //可推移
        collides: false, //可碰撞
        friction: 0, //无摩擦力
        mass: 0.01, //非常轻
    })

    const tgPos = entity.position//僚机的目标位置
    const budPos = buddy.position//僚机的当前位置
    const facing = entity.player.facingDirection//玩家的朝向
    const ratio = 0.3//追随的灵敏度, 最好设在0.5左右, 1.0表示立即移到玩家位置

    const dist = 2 //与玩家保持的距离
    const yOffset = y //y轴位移, 保持僚机在头顶或脚下

    const ticker = world.onTick(() => {

        //要让小精灵跟在玩家背后, 需要计算xz轴的位移: 玩家朝向的反方向
        const xOffset = -facing.x * dist
        const zOffset = -facing.z * dist

        //当前位置与目标位置在xyz轴的差距
        const xDiff = tgPos.x - budPos.x
        const yDiff = tgPos.y - budPos.y
        const zDiff = tgPos.z - budPos.z

        //计算xyz方向上 当前位置向目标位置靠拢的速度
        const vx = (xDiff + xOffset) * ratio
        const vy = (yDiff + yOffset) * ratio
        const vz = (zDiff + zOffset) * ratio

        buddy.velocity.set(vx, vy, vz)//设置僚机速度

        if (buddy.velocity.sqrMag() > 0.005) {//速度要足够大, 才触发转向, 防止抖动
            buddy.meshOrientation = Quat.rotateY(Math.atan2(zDiff, xDiff)) //让小精灵一直面向玩家
        }
    })

    return () => {
        ticker.cancel() //关掉tick循环
        buddy.destroy() //移除僚机实体
    }
}

world.onPlayerJoin(({ entity }) => {
    entity.setPet = buddyFollow(entity, 'mesh/万圣南瓜.vb', -1) //给玩家增加宠物，名称需与地图内放置的模型的名称一致
})

world.onPlayerLeave(({ entity }) => {
    //玩家离开地图时, 切记一定要关掉tick循环以及销毁小精灵实体, 否则随着人数增加, 服务器积累到一定程度就会崩溃
    entity.setPet() //清除掉宠物
})




//require('./script_2.js')




console.clear()//清除控制台记录
const hd = world.querySelector('#万圣节告示牌');
hd.enableInteract = true;
hd.interactHint = '万圣节告示牌';
hd.interactRadius = 6;
hd.onInteract(async ({ entity }) => {
    const hdz = [1];

    const hdl = await entity.player.dialog({
        type: Box3DialogType.SELECT,
        title: '万圣节告示牌',
        content: `你好，${entity.player.name}，很高兴认识你。目前版本——v.3 核对好版本游玩体验最佳哦~`,
        options: hdz
    })
    if (!hdl || hdl == null || hdl.value == '') return;
    for (const a of hdxm) {
        if (a.name == hdl.value) {
            a.dialog(entity);
            break;
        }
    }
})

world.querySelectorAll('.test').forEach((e) => {
    var type = 'r';
    world.onTick(() => {
        if (e.position.z >= 11) {
            e.position.z -= 0.3;
            type = 'l';
        } else if (e.position.z <= 6) {
            e.position.z += 0.3;
            type = 'r';
        } else {
            if (type === 'r') {
                e.position.z += 0.3;
            } else {
                e.position.z -= 0.3;
            }
        }
    })
})
world.onPlayerJoin(({ entity }) => {
    entity.player.addWearable({
        bodyPart: Box3BodyPart.TORSO,
        mesh: 'mesh/.vb',
        orientation: new Box3Quaternion(0, 1, 0, 0).rotateY(Math.PI / 2),
        scale: new Box3Vector3(1, 1, 1),
        offset: new Box3Vector3(0, 0, -0.45),
    });
});
world.onPlayerJoin(({ entity }) => {
    entity.player.addWearable({
        bodyPart: Box3BodyPart.TORSO,
        mesh: 'mesh/.vb',
        orientation: new Box3Quaternion(0, 1, 0, 0).rotateY(Math.PI / 2),
        scale: new Box3Vector3(0.5, 0.5, 0.5),
        offset: new Box3Vector3(0, 0, -0.45),
    });
});
world.onPlayerJoin(({ entity }) => {
    entity.player.addWearable({
        bodyPart: Box3BodyPart.HEAD,
        mesh: 'mesh/万圣节女巫帽.vb',            //使用代码时，此处的名称需与地图中的模型名称保持一致
        orientation: new Box3Quaternion(0, 0, 0, 0).rotateY(-Math.PI / 1),
        offset: new Box3Vector3(0, 1.5, 0),
    });

});



for (const npc of world.querySelectorAll('.NPC')) {
    npc.enableInteract = true
    npc.interactRadius = 4.5
    npc.interactHint = npc.id
    npc.interactColor.set(0, 1, 0)
    if (npc.id == '吉吉喵的分身') {
        npc.onInteract(async ({ entity }) => {
            textDialog(entity, `${entity.player.name}, 恭喜你完成了跑酷的第一季后面还会更新的1赞更新1关20赞更新1期50赞更新一季~其实作者已经更新第二季了想去的话就从我后面的传送门去吧`, npc.id)
        })
    }
    else if (npc.id == '克苏鲁之眼') {
        npc.onInteract(async ({ entity }) => {
            textDialog(entity, `哈哈${entity.player.name}我是克苏鲁遗留下的的精神部分，废话不用多说，偷偷告诉你一个方法，可以让这个地图崩溃，就是有10000人一起进来就能让这个地图崩溃了，哈哈哈哈哈哈哈哈哈呵呵哈哈哈哈哈哈哈哈哈呵呵哈哈哈哈哈哈哈哈哈~`, npc.id)
        })
    }
    else if (npc.id == '奥特曼-泽塔') {
        npc.onInteract(async ({ entity }) => {
            textDialog(entity, `你好${entity.player.name}我是泽塔奥特曼，最近光之国的奥特之父告诉我这里有怪物的脑电波，好像是怪物克苏鲁，你看见了吗？，如果看见了`, npc.id)
        })
    }
}
for (const npc of world.querySelectorAll('.密钥门')) {
    npc.enableInteract = true
    npc.interactRadius = 4
    npc.interactHint = npc.id
    if (npc.id == '密钥门') {
        npc.onInteract(async ({ entity }) => {
            const mm = await entity.player.dialog({
                type: Box3DialogType.INPUT,
                content: '请输入密钥：',
                title: npc.id
            })
            if (mm == '密码') {
                entity.player.directMessage(`密钥正确！请进`)
                entity.position.set(207.88, 11.76, 103.50)
            }
            else {
                entity.player.directMessage(`密钥错误！被认为入侵者，扣10滴血！`)
                entity.hurt(10)
            }
        })
    }
}
for (const e of world.querySelectorAll('*')) {//遍历所有实体
    if (e.id.startsWith('存档点')) {
        e.collides = true //开启碰撞
        e.fixed = true //固定实体不被推移
        e.meshScale = e.meshScale.scale(2) //放大零倍
        e.onEntityContact(({ other }) => {
            if (other.isPlayer) {
                if (e.position !== other.player.spawnPoint) {
                    other.player.directMessage('到达新的存档点')
                    other.player.spawnPoint = e.position // 玩家重生点坐标设置成存档点的坐标
                }
            }
        })
    }
}
world.onPlayerJoin(({ entity }) => {
    entity.onFluidEnter(() => {//当玩家掉到水里
        entity.position.copy(entity.player.spawnPoint)
        entity.position.y += 4
    })
})
world.onVoxelContact(({ entity, x, y, z, voxel }) => {
    const voxelName = voxels.name(voxel);
    if (voxelName === 'windygrass') {
        voxels.setVoxel(x, y, z, 'air');
        setTimeout(() => { voxels.setVoxel(x, y, z, voxel) }, 3000);
    } else if (voxelName === '') {
        voxels.setVoxel(x, y, z, 0);
    }
});

world.onPlayerJoin(({ entity }) => {
    entity.onFluidEnter(() => {//当玩家掉到水里
        entity.position.copy(entity.player.spawnPoint)
        entity.position.y += 4
    })
})
console.clear()
var door = world.querySelector('#传送门')
door.enableInteract = true
door.interactRadius = 5
door.interactHint = '传送到下一关～'

door.onInteract(({ entity }) => {
    entity.position.set(151, 12, 20)
})
console.clear()

console.clear()
var door = world.querySelector('#未来传送门-4')
door.enableInteract = true
door.interactRadius = 5
door.interactHint = '传送到出生点'

door.onInteract(({ entity }) => {
    entity.position.set(250, 13, 3)
})
var door = world.querySelector('#未来传送门-1')
door.enableInteract = true
door.interactRadius = 5
door.interactHint = '传送到下一关'

door.onInteract(({ entity }) => {
    entity.position.set(60, 10, 1)
})
var door = world.querySelector('#未来传送门-5')
door.enableInteract = true
door.interactRadius = 5
door.interactHint = '传送到挂机室'

door.onInteract(({ entity }) => {
    entity.position.set(126, 53, 130)
})
            </code>
                                                </pre>
                                </div>
                            </div>
                        </div>
                        <div class="panel panel-default">
                            <div class="panel-heading">
                                <a class="panel-title collapsed" data-toggle="collapse" data-parent="#panel-586155"
                                    href="#panel-element1-2">带堆叠的背包</a>
                            </div>
                            <div id="panel-element1-2" class="panel-collapse collapse">
                                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
                                    <pre>
            <code class="language-js">
                /**
 * !info {Project} -来自Nomen
 * 带堆叠上限的背包系统（？
 */



const topBag = 64;//物品堆叠上限，默认64


world.onPlayerJoin(async ({ entity }) => {
    entity.bag = [];
    Object.assign(entity, {
        give: function (name, count) {
            if (count > topBag) return;//检测输入是否大于背包最大堆叠
            if (name === undefined || count === undefined) return;//检测信息是否完全，防止报错
            var prop = [];
            for (let i in this.bag) { if (this.bag[i].name == name) prop.push(parseInt(i)); }//抽取所有此物品的项目
            if (prop.length == 0) { this.bag.push({ name, count }); return; }//如果不存在项目，则直接推入物品
            if ((this.bag[prop[prop.length - 1]].count + count) > topBag) {//如果存在该项目但是剩余空间不足
                if (this.bag[prop[prop.length - 1]].count == topBag) { this.bag.push({ name, count }); return; }
                let c = this.bag[prop[prop.length - 1]].count
                this.bag[prop[prop.length - 1]].count = topBag;//补全当前项目
                this.bag.push({ name, count: count - (topBag - c) })//将多余最高堆叠的项目推入背包 topBag-(count-(this.bag[prop[prop.length-1]].count))  
            } else {
                this.bag[prop[prop.length - 1]].count += count//否则直接推入项目
            }
        },
        show: function () {
            this.bag.forEach((item) => {
                console.log(item.name, ":", item.count)
            })
        },
        remove: function (name, count) {
            if (name === undefined || count === undefined) return;//检测信息是否完全，防止报错
            var prop = [];
            for (let i in this.bag) { if (this.bag[i].name == name) prop.push(parseInt(i)); }//抽取所有此物品的项目
            var allCount = 0;
            prop.forEach((elei) => { allCount += this.bag[elei].count; })
            if (allCount < count) return false;
            for (let i = prop.length-1;i>=0;i--) {
                if (this.bag[prop[(i)]].count >= count) {
                    this.bag[prop[(i)]].count -= count;
                    if (this.bag[prop[(i)]].count == 0) this.bag.splice(prop[i], 1);
                    console.warn(this.bag[prop[(i)]].count)
                    return true;
                } else {
                    count -= this.bag[prop[(i)]].count;
                    this.bag.splice(prop[i], 1);
                }
            }
        }
    })
})
            </code>
                                                </pre>
                                </div>
                            </div>
                        </div>
                        <div class="panel panel-default">
                            <div class="panel-heading">
                                <a class="panel-title collapsed" data-toggle="collapse" data-parent="#panel-586155"
                                    href="#panel-element1-3">摔落伤害</a>
                            </div>
                            <div id="panel-element1-3" class="panel-collapse collapse">
                                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
                                    <pre>
            <code class="language-js">
                /**
 * !info {Project} -来自网络
 * 衰落伤害
 */



voxels.isFluid = (voxel) => { return ['water', 364, 'strawberry_juice', 412, 'lime_juice', 414, 'blueberry_juice', 416, 'lemon_juice', 418, 'grape_juice', 420, voxels.name(422), 422, voxels.name(424), 424, voxels.name(426), 426, voxels.name(428), 428, voxels.name(430), 430].includes(voxel) }
var xzCo = 0.44921875
var yCo = 1.6
world.onPlayerJoin(async ({ entity }) => {
    entity.enableDamage = true
    entity.maxHp = 100
    entity.hp = 100
    const g = voxels.getVoxel
    entity.fallHigh = 0
    entity.highY = entity.position.y
    entity.contactList = () => {
        return [
            g(entity.position.x + xzCo, entity.position.y - yCo, entity.position.z + xzCo),
            g(entity.position.x + xzCo, entity.position.y - yCo, entity.position.z - xzCo),
            g(entity.position.x - xzCo, entity.position.y - yCo, entity.position.z + xzCo),
            g(entity.position.x - xzCo, entity.position.y - yCo, entity.position.z - xzCo),
            g(entity.position.x + xzCo, entity.position.y - yCo, entity.position.z),
            g(entity.position.x - xzCo, entity.position.y - yCo, entity.position.z),
            g(entity.position.x, entity.position.y - yCo, entity.position.z + xzCo),
            g(entity.position.x, entity.position.y - yCo, entity.position.z - xzCo),
            g(entity.position.x, entity.position.y - yCo, entity.position.z)]
    }
    entity.ifContact = function () {
        for (const count of entity.
            contactList()) {
            if (count != 0) {
                if (voxels.isFluid(count)) {
                    this.fallHigh = 0
                    return false
                } return true
            }
        } return false
    }
    while (entity) {
        await sleep(64)
        if (entity.ifContact()) {
            if (voxels.isFluid(g(entity.position.x, entity.position.y - 1, entity.position.z))) continue
            if (entity.fallHigh > 6) {
                const hurt = entity.fallHigh / 3 * 18 * ~(world.gravity * 100) / 100
                entity.hurt(hurt)
                entity.player.directMessage(`你受到${hurt}点高空伤害`)
                entity.fallHigh = 0
            } else {
                entity.fallHigh = 0
            }
        } if (entity.highY > Math.floor(entity.position.y)) {
            entity.fallHigh += 1
            entity.highY = Math.floor(entity.position.y)
        } else {
            entity.highY = Math.floor(entity.position.y)
        }
    }
})
world.onFluidEnter(({ entity }) => {
    if (entity.isPlayer) entity.fallHigh = 0
})
            </code>
                                                </pre>
                                </div>
                            </div>
                        </div>
                        <div class="panel panel-default">
                            <div class="panel-heading">
                                <a class="panel-title collapsed" data-toggle="collapse" data-parent="#panel-586155"
                                    href="#panel-element1-4">围棋</a>
                            </div>
                            <div id="panel-element1-4" class="panel-collapse collapse">
                                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
                                    <pre>
            <code class="language-js">
                /**
 * !info {Project} -来自网络
 * 围棋
 */


console.clear();

// 贴目
const KOMI = 7.5;

// 聊天命令
const RESIGN_RE = /^我认输/i;
const PASS_RE = /^过/i;
const FINISH_COUNT_RE = /^清点完毕/i;
const RESET_RE = /^重置/i;

// 管理员
const ADMIN_NAMES = ['吉吉喵', 'Gorikokka'];

// 每秒多少tick
const TICKS_PER_SECOND = (1024 / 64);
// 基本时限
const MAIN_TICKS = 10 * 60 * TICKS_PER_SECOND;
// 基本时限用完后的读秒时间
const LIGHTNING_TICKS = 10 * TICKS_PER_SECOND;

// 是否允许自我对弈
const ALLOW_SELF_PLAY = false;

// 数字方块
const DIGIT = [
    'zero',
    'one',
    'two',
    'three',
    'four',
    'five',
    'six',
    'seven',
    'eight',
    'nine',
];

// 棋盘方块
const B = {
    '+': voxels.id('board1'),
    'T': voxels.id('board4'),
    'L': voxels.id('board3'),
    '.': voxels.id('board2'),
}

// 用户控制方块旋转
const R = {
    N: 0x8000,
    S: 0,
    E: 0xc000,
    W: 0x4000,
};

// 棋子名称
const COLORS = [
    '黑',
    '白',
];

// 正常棋子的mesh
const STONE_MESH = [
    world.querySelector('.black_stone').mesh,
    world.querySelector('.white_stone').mesh,
];

// 标红棋子的mesh
const CURRENT_STONE_MESH = [
    world.querySelector('.cur_black_stone').mesh,
    world.querySelector('.cur_white_stone').mesh,
];

// 碗的mesh
const BOWL_MESH = [
    world.querySelector('.black_bowl').mesh,
    world.querySelector('.white_bowl').mesh,
];

// 按钮的mesh
const CHOOSE_BUTTON_MESH = world.querySelector('.choose_button').mesh;

const teleport = (function(/* 传送相关 */) {
    const locations = {};
    // 获取预置的地点
    world.querySelectorAll('.地点').forEach((e) => {
        locations[e.id] = e.position;
        e.destroy();
    });
    // 处理绝对传送
    world.onEntityContact(({entity, other}) => {
        if (other.isPlayer && entity.hasTag('绝对传送')) {
            const attr = getEntityAttr(entity);
            const pos = locations[attr['目的地']];
            if (pos) other.position.copy(pos);
        }
    });
    // 处理相对传送
    world.onEntityContact(({entity, other}) => {
        if (other.isPlayer && entity.hasTag('相对传送')) {
            const attr = getEntityAttr(entity);
            other.position.addEq({
                x: Number(attr.x) || 0,
                y: Number(attr.y) || 0,
                z: Number(attr.z) || 0,
            });
        }
    });
    return function(e, name) {
        const pos = locations[name];
        if (e && e.isPlayer && pos) e.position.copy(pos);
    }
})();

// 创建游戏实例
async function playGo (name, size, originX, originY, originZ) {
    // 用于计算星点x的位置
    const STAR_MOD = {
        19: [6, 3],
        13: [3, 0],
        9: [2, 0],
        7: [2, 0],
    };
    // 计时条长度
    const CLOCK_LENGTH = size <= 9 ? 3 : 5;

    // 棋盘大小, 默认19
    if (!(size in STAR_MOD)) {
        size = 19;
    }

    // 存储某个位置的棋子的实体对象
    const pieces = new Array(size * size);
    // 记录某个位置的棋子颜色. -1:空, 0:黑, 1:白
    const board = new Array(size * size);
    // 用于标记某个位置是否被访问过(用于搜索算法)
    const visited = new Array(size * size);
    // 存储所有棋盘状态, 用于判断全局同形
    const prevBoards = [];
    // 对弈双方玩家的实体
    const playerEntities = [ null, null ];
    // 对弈双方玩家的名称
    const playerNames = ['NULL', 'NULL'];
    // 双方的分数
    const score = [ 0, 0 ];
    // 双方的计时
    const clock = [ 0, 0 ];
    // 当前玩家 0:黑, 1:白
    let currentPlayer = 0;
    // 游戏状态 wiat:等待, play:对局中, end:结束
    let gameState = 'wait';
    // 记录连续过的次数, 达到两次时则结束对局
    let passCount = 0;
    // 上次落子的位置
    let lastPieceIdx = -1;
    // 记录该房间的玩家, 对局开始后会把非对局玩家传送到场外
    const visitors = new Set();

    // 用于发送通知
    function broadcast(s) {
        world.say(`[${name}]: ${s}`);
    }

    // 处理对局开始前离开的玩家
    function leaveVisotor(e) {
        teleport(e, `${name}观战室`);
        for (let i = 0; i < 2; i++) {
            if (playerEntities[i] == e) {
                playerEntities[i] = null;
                playerNames[i] = null;
            }
        }
        visitors.delete(e);
    }
    // 玩家离开房间的处理
    world.querySelector(`.${name}离开房间`).onEntityContact(({other}) => {
        if (gameState === 'play') {
            resign(other);
        } else {
            leaveVisotor(other);
        }
    });
    // 触碰到入口, 直接传送到下方
    world.querySelector(`.${name}入口`).onEntityContact(({other}) => {
        if (gameState !== 'play') {
            visitors.add(other);
            other.position.y -= 5;
        }
    });
    // 创建棋盘
    function createBoard () {
        const [MOD, VAL] =  STAR_MOD[size];
        const border = voxels.id('palace_lamp');
        const borderLight = voxels.id('lantern_02');
        // 边缘上方的白灯
        voxels.setVoxelId(originX - 1, originY + 1, originZ - 1, borderLight);
        voxels.setVoxelId(originX + size, originY + 1, originZ - 1, borderLight);
        voxels.setVoxelId(originX - 1, originY + 1, originZ + size, borderLight);
        voxels.setVoxelId(originX + size, originY + 1, originZ + size, borderLight);
        // 棋盘边缘的灯
        for (let i = 0; i <= size; ++i) {
            voxels.setVoxelId(originX + i, originY, originZ + size, border);
            voxels.setVoxelId(originX + i - 1, originY, originZ - 1, border);
            voxels.setVoxelId(originX + size, originY, originZ + i - 1, border);
            voxels.setVoxelId(originX - 1, originY, originZ + i , border);
        }
        // 创建size * size的棋盘
        for (let x = 0; x < size; ++x) {
            for (let z = 0; z < size; ++z) {
                // 通常来讲是交点
                let p = B['+'];
                // 以下四个判断用于判断是否是边角
                if (x === 0 && z === 0) { 
                    p = B['L'] | R['S'];
                } else if (x === 0 && z === size - 1) {
                    p = B['L'] | R['E'];
                } else if (x === size -1 && z === 0) {
                    p = B['L'] | R['W'];
                } else if (x === size -1 && z === size - 1) {
                    p = B['L'] | R['N'];
                // 以下四个判断用于判断是否是边缘
                } else if (x === 0) {
                    p = B['T'] | R['E'];
                } else if (x === size -1) {
                    p = B['T'] | R['W'];
                } else if (z === 0) {
                    p = B['T'] | R['S'];
                } else if (z === size -1) {
                    p = B['T'] | R['N'];
                // 判断是否是星点
                } else if (x > 0 && x < size - 1 && z > 0 && z < size - 1 && (x % MOD) === VAL && (z % MOD) === VAL) {
                    p = B['.'];
                }
                voxels.setVoxelId(x + originX, originY, z + originZ, p);
            }
        }
    }

    // 用于绘制数字条
    function drawNumber (x, y, z, n, dx, dz, rotation) {
        for (let i = 0; i < CLOCK_LENGTH; ++i) {
            voxels.setVoxel(x, y, z, DIGIT[n % 10], rotation);
            x += dx;
            z += dz;
            n = (n / 10) | 0;
        }
    }

    // 绘制双方的计时
    function drawClock(time) {
        drawNumber(originX + size + 2, originY - 1, originZ + size - CLOCK_LENGTH + 1, time !== undefined ? time : (clock[0] / TICKS_PER_SECOND) | 0, 0, 1, 3);
        drawNumber(originX - 3, originY - 1, originZ + CLOCK_LENGTH - 2, time !== undefined ? time : (clock[1] / TICKS_PER_SECOND) | 0, 0, -1, 5);
    }

    // 把二维棋盘位置x, y变换为数组下标, 用于pieces和board
    function index (x, y) {
        return x + y * size;
    }

    // 初始化游戏
    function setup () {
        // 重置棋盘
        for (let i = 0; i < size * size; ++i) {
            board[i] = -1;
            if (pieces[i]) {
                pieces[i].destroy();
            }
            pieces[i] = null;
        }
        // 重置分数
        score[0] = 0;
        score[1] = KOMI;
        // 重置当前玩家
        currentPlayer = 0;
        // 重置历史棋盘状态
        prevBoards.length = 0;
        // 重置玩家
        playerEntities[0] = playerEntities[1] = null;
        playerNames[0] = playerNames[1] = 'NULL'
        // 重置状态
        gameState = 'wait';
        // 重置连续过的次数
        passCount = 0;
        // 重置计时
        clock[0] = clock[1] = MAIN_TICKS;
    }

    // 检查某个位置是否有气
    function hasLiberties (pX, pY) {
        // 重置visited
        visited.fill(false);
        // 初始化访问队列
        const toVisit = [ pX, pY ];
        // 获取起始点颜色
        const c = board[index(pX, pY)];
        // 标记起始点为已访问
        visited[index(pX, pY)] = true;

        // 默认无气
        let libs = false;
        // 把x,y放入访问队列
        function push (x, y) {
            const idx = index(x, y);
            // 访问过了就不放
            if (visited[idx]) {
                return;
            }
            const d = board[idx];
            if (d === c) {
                // 颜色相同才放
                toVisit.push(x, y);
                visited[idx] = true;
            } else if (d < 0) {
                // 该位置(x, y)为空, 表示有气
                libs = true;
            }
        }
        // 广度优先算法(BFS)
        for (let i = 0; i < toVisit.length; i += 2) {
            // 获取队列前端的位置
            const x = toVisit[i];
            const y = toVisit[i + 1];
            // 向上下左右四个方向进行搜索
            if (x > 0) { push(x - 1, y); }
            if (x < size - 1) { push(x + 1, y); }
            if (y > 0) { push(x, y - 1); }
            if (y < size - 1) { push(x, y + 1); }
        }
        // 返回结果
        return libs;
    }

    // 计算提子
    function capture (x, y, koTest) {
        // 无子直接返回
        if (board[index(x, y)] < 0) {
            return;
        }
        const libs = hasLiberties(x, y);
        // 对局中, 有气不能提子
        if (gameState === 'play' && libs) {
            return;
        }
        for (let x = 0; x < size; ++x) {
            for (let y = 0; y < size; ++y) {
                const idx = index(x, y);
                // 复用hasLiberties产生的访问结果, 被访问过表示需要被提走
                if (visited[idx]) {
                    // 如果不是预演, 就执行提子
                    if (!koTest) {
                        // 对方玩家
                        const c = board[idx] ^ 1;
                        // 棋子实体
                        const p = pieces[idx];
                        // 对方分数+1
                        score[c] += 1;
                        // 销毁棋子
                        p.destroy();
                        pieces[idx] = null;
                    }
                    // 标记为空
                    board[idx] = -1;
                }
            }
        }
    }

    // 恢复棋子
    function restorePiece() {
        if (lastPieceIdx >= 0 && pieces[lastPieceIdx]) {
            pieces[lastPieceIdx].mesh = STONE_MESH[board[lastPieceIdx]];
        }
    }

    // 落子
    function placePiece (x, y) {
        const c = currentPlayer;
        const idx = index(x, y);

        // 检查落子位置是否为空
        if (board[idx] >= 0) {
            return;
        }

        // 尝试落子
        board[idx] = c;
        
        // 备份棋盘状态
        const koTest = board.slice();

        // 预演计算提子
        if (x > 0) { capture(x - 1, y, true); }
        if (x < size - 1) { capture(x + 1, y, true); }
        if (y > 0) { capture(x, y - 1, true); }
        if (y < size - 1) { capture(x, y + 1, true); }
        capture(x, y, true);

        // 计算提子后的状态
        const ko = board.join();

        // 恢复棋盘到计算提子前的状态
        for (let j = 0; j < koTest.length; ++j) {
            board[j] = koTest[j];
        }

        // 检查当前棋盘状态是否已经出现过
        for (let i = 0; i < prevBoards.length; ++i) {
            if (prevBoards[i] === ko) {
                // 状态重复, 落子无效
                board[idx] = -1;
                return;
            }
        }

        // 复原上个棋子
        restorePiece();
        // 创建棋子对象
        pieces[idx] = world.createEntity({
            position: [
                originX + x + 0.5,
                originY + 1.125,
                originZ + y + 0.5,
            ],
            meshScale: [1 / 24, 1 / 24, 1 / 24],
            mesh: CURRENT_STONE_MESH[c],
            gravity: false,
            collides: true,
            fixed: true,
        });

        // 计算提子(这回事真的了)
        if (x > 0) { capture(x - 1, y); }
        if (x < size - 1) { capture(x + 1, y); }
        if (y > 0) { capture(x, y - 1); }
        if (y < size - 1) { capture(x, y + 1); }
        capture(x, y);
        
        // 保存当前棋盘状态
        prevBoards.push(board.join());

        // 切换到下个玩家
        currentPlayer ^= 1;

        // 清空pass计数
        passCount = 0;

        // 更新clock
        clock[currentPlayer] = Math.max(clock[currentPlayer], LIGHTNING_TICKS);

        // 更新最后落子的位置
        lastPieceIdx = idx;
        return true;
    }

    // 计算分数
    function countScore () {
        visited.fill(false);
        // 表示空地是否和黑子/白子相邻
        const adj = [ false, false ];
        // 计算x,y的得分
        function count (x, y) {
            // 棋盘外为0分
            if (x < 0 || y < 0 || x >= size || y >= size) {
                return 0;
            }

            const idx = index(x, y);
            // 之前访问过(计算过)为0分
            if (visited[idx]) {
                return 0;
            }
            // 标记为访问过(计算过)
            visited[idx] = true;

            const b = board[idx];
            // 空地才计算
            if (b === -1) {
                return (1 + // 空地本身1分
                    // 递归的计算上下左右的分数
                    count(x - 1, y) +
                    count(x + 1, y) + 
                    count(x, y - 1) +
                    count(x, y + 1)
                );
            }
            // 不是空地, 则标记为可已达到某个颜色的棋子
            adj[b] = true;
            return 0;
        }
        // 遍历size*size棋盘的每个棋子
        for (let x = 0; x < size; ++x) {
            for (let y = 0; y < size; ++y) {
                // 初始化标记
                adj[0] = adj[1] = false;
                // 计算得分
                const s = count(x, y);
                // 只能有一方获得该分数
                if (adj[0] && !adj[1]) {
                    score[0] += s;
                } else if (adj[1] && !adj[0]) {
                    score[1] += s;
                }
            }
        }
    }

    // 过
    function pass (entity) {
        if (gameState === 'play') {
            if (entity === playerEntities[currentPlayer]) {
                broadcast(`${playerNames[currentPlayer]} 弃权一手`);
                // 增加过的技术
                passCount += 1;
                // 切换当前玩家
                currentPlayer ^= 1;

                // 更新clock
                clock[currentPlayer] = Math.max(clock[currentPlayer], LIGHTNING_TICKS);

                // 连续过2次 对局结束
                if (passCount >= 2) {
                    restorePiece();
                    gameState = 'count';
                    passCount = 0;
                    currentPlayer = -1;
                    broadcast('请点击对方死子进行标记');
                    broadcast('点击己方已被标记的棋子表示确认死子');
                    broadcast('双方清点完成后请发送 清点完毕');
                }
            }
        }
    }
    
    // 认输
    function resign (entity) {
        for (let i = 0; i < 2; ++i) {
            if (entity === playerEntities[i]) {
                if (gameState === 'play' || gameState === 'count') {
                    broadcast(`${playerNames[i]} 认输`);
                    score[i] = -Infinity;
                    gameState = 'done';
                }
            }
        }
    }

    // 清点完毕
    function finishCount (entity) {
        if (gameState === 'count') {
            for (let i = 0; i < 2; ++i) {
                if (entity === playerEntities[i]) {
                    passCount |= 1 << i;
                }
            }
            if (passCount === 3) {
                gameState = 'done';
            }
        }
    }

    // 创建期盼
    createBoard();
    // 绘制计时
    drawClock(0);
    // 创建碗
    [
        [originX + size + 3, originZ],
        [originX - 3, originZ + size],
    ].map(([x, z], i) => world.createEntity({
        position: [
            x,
            originY + 0.5,
            z,
        ],
        mesh: BOWL_MESH[i],
        meshScale: [1 / 16, 1 / 16, 1 / 16],
        fixed: true,
        collides: true,
        gravity: false,
    }));
    // 创建选择按钮
    const chooseButtons = [originX + size + 2.5, originX - 2.5].map((x) => world.createEntity({
        position: [
            x,
            originY + 0.3,
            originZ + size / 2,
        ],
        mesh: CHOOSE_BUTTON_MESH,
        meshScale: [1 / 24, 1 / 24, 1 / 24],
        fixed: true,
        collides: true,
        gravity: false,
    }))

    // 下棋处理
    const removeTips = [false, false];
    world.onPress(({ entity, button, raycast:{ hitPosition:{x, y, z}, hitEntity } }) => {
        if (gameState === 'play') { // 正常落子
            // 对局
            if (button !== 'action0' || // 判断按钮
                entity !== playerEntities[currentPlayer] || // 是否是对弈的玩家
                Math.abs(y - originY) > 2) { // 是否在棋盘上方
                return;
            }
            // 计算位置
            const dx = Math.floor(x) - originX;
            const dz = Math.floor(z) - originZ;
            // 判断是否在棋盘上
            if (dx < 0 || dx >= size || dz < 0 || dz >= size) {
                return;
            }
            // 落子
            placePiece(dx, dz);
        } else if (gameState === 'count' && hitEntity) { // 清算死子
            const idx = pieces.indexOf(hitEntity);
            if (idx < 0) {
                return;
            }
            const x = Math.floor(hitEntity.position.x - originX);
            const y = Math.floor(hitEntity.position.z - originZ);
            const c = board[idx];
            if (entity !== playerEntities[c]) {
                // 点击对方棋子, 切换标记状态
                if (hitEntity.mesh === STONE_MESH[c]) {
                    hitEntity.mesh = CURRENT_STONE_MESH[c];
                    // 只提示一次, 不然太烦人了
                    if (!removeTips[c]) {
                        hitEntity.say(`请${playerNames[c]}确认死子`);
                        removeTips[c] = true;
                    }
                } else if (hitEntity.mesh === CURRENT_STONE_MESH[c]) {
                    hitEntity.mesh = STONE_MESH[c];
                }
            } else if (hitEntity.mesh === CURRENT_STONE_MESH[c]) {
                // 点击了己方已被标记的棋子, 表示确认为死子, 执行提子
                capture(x, y);
            }
        }
    });

    // 选择按钮
    chooseButtons.forEach((button, c) => {
        button.onEntityContact(({ other }) => {
            if (gameState === 'wait' && other.isPlayer && playerEntities[c] !== other) {
                playerEntities[c] = other;
                playerNames[c] = other.player.name;
                broadcast(`${playerNames[c]}执${COLORS[c]}棋`);
                // 如果不允许自我对弈, 则只能选择一方
                if (!ALLOW_SELF_PLAY && playerEntities[c^1] === other) {
                    playerEntities[c^1] = null;
                    playerNames[c^1] = 'NULL';
                }
            }
        });
    });

    // 离开则认输
    world.onPlayerLeave(({ entity }) => resign(entity));

    // 可以通过聊天来过或认输
    world.onChat(({ entity, message }) => {
        if (message.match(PASS_RE)) {
            pass(entity);
        } else if (message.match(RESIGN_RE)) {
            resign(entity);
        } else if (message.match(FINISH_COUNT_RE)) {
            finishCount(entity);
        } else if (ADMIN_NAMES.includes(entity.player.name) && message.match(RESET_RE)) {
            const resetName = message.split(/\s+/)[1];
            if (resetName === name && gameState != 'wait') {
                gameState = 'done';
                broadcast(`管理员${entity.player.name}进行了重置`)
            }
        }
    });
    
    while (true) {
        // 初始化
        setup();

        // 等待双方玩家选择颜色
        while (!playerEntities[0] || !playerEntities[1]) {
            await world.nextTick();
        }

        // 把非对弈玩家传送走
        for (const v of visitors) {
            if (playerEntities.includes(v)) continue;
            teleport(v, `${name}观战室`);
        }
        visitors.clear();

        broadcast('对局开始');
        gameState = 'play';
        // 处理每回合, 直到对局结束
        while (gameState === 'play') {
            await world.nextTick();
            if (--clock[currentPlayer] <= 0) {
                pass(playerEntities[currentPlayer]);
            }
            drawClock();
        }

        if (gameState !== 'done') {
            // 等待清算完毕
            while (gameState === 'count') {
                await world.nextTick();
            }
            // 计算分数
            countScore();
            // 通知结果
            broadcast(`对局结束: 黑棋${score[0]}目 vs 白棋${score[1]}目`);
            const winner = score[0] > score[1] ? 0 : 1;
            broadcast(`执${COLORS[winner]}棋的选手${playerNames[winner]}获胜.`);
        }

        // 清空计时
        drawClock(0);
        // 把对弈玩家传送走
        playerEntities.forEach((e) => teleport(e, `${name}观战室`));
        // 既然对局已经结束, 就让棋盘上的棋子动起来, 这样会很有趣
        pieces.forEach((p) => {
            if (p) {
                p.collides = true;
                p.fixed = false;
                p.gravity = true;
                p.velocity.x += 0.1 * (Math.random() - 0.5);
                p.velocity.y += 0.1 * Math.random();
                p.velocity.z += 0.1 * (Math.random() - 0.5)
            }
        });

        // 十秒后开始下一轮
        await sleep(10 * 1000);
    }
}

// 获取通过标签定义的实体属性
function getEntityAttr(e) {
    const attr = {};
    e.tags().forEach((tag) => {
        const g = tag.match(/(\S+)\s*:\s*(\S+)/);
        if (g) {
            attr[g[1]] = g[2];
        }
    });
    return attr;
}

// 在所有添加了go_spawner的实体的位置 创建游戏实例
world.querySelectorAll('.go_spawner').forEach((e) => {
    const attr = getEntityAttr(e);
    if ('name' in attr) {
        playGo(attr.name, parseInt(attr.size) || 9,
            Math.floor(e.position.x),
            Math.floor(e.position.y),
            Math.floor(e.position.z));
    }  
});
    

// 删除临时实体
world.querySelectorAll('.temporary').forEach((e) => e.destroy());
// 对所有玩家启用ActionA
world.onPlayerJoin(({ entity }) => {
    entity.player.enableActionA = true;
});
            </code>
                                                </pre>
                                </div>
                            </div>
                        </div>
                        <div class="panel panel-default">
                            <div class="panel-heading">
                                <a class="panel-title collapsed" data-toggle="collapse" data-parent="#panel-586155"
                                    href="#panel-element1-5">指令系统</a>
                            </div>
                            <div id="panel-element1-5" class="panel-collapse collapse">
                                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
                                    <pre>
            <code class="language-js">
/**
 * !info {Project} -来自Nomen
 * 指令系统，在聊天框输入“/mute Nomen“
 */



console.clear()
world.addCollisionFilter('player', 'player')
world.onPlayerJoin(({entity})=>{
    entity.player.spawnPoint = new Box3Vector3(16, 11, 16)
    entity.player.forceRespawn()
})

world.onPlayerJoin(async ({ entity }) => {
    entity.isOP=['Nomen'].includes(entity.player.name)?true:false;
    Object.assign(entity, {
        'ban': function (name) {
            if (!entity.isOP) { entity.player.directMessage('权限不足'); return; }
            find(name).player.kick()
        },
        'kill': function (name) {
            if (!entity.isOP) { entity.player.directMessage('权限不足'); return; }
            find(name).hp = 0;
        },
        'mute': function (name) {
            if (!entity.isOP) { entity.player.directMessage('权限不足'); return; }
            find(name).player.mute = !find(name).player.mute;
        },
        'fix': function () {
            entity.hp = 0;
        },
        'help': function (name) {
            commandList.forEach((com) => {
                entity.player.directMessage(com);
            })
        },
        'add': function (...param) {
            let a = 0;
            param.forEach((r) => {
                a += r;
            })
            entity.player.directMessage(a)
        },
    })
})

world.onChat(({ message: m, entity }) => {
    if (m[0] == '$' && admin.includes(e.player.name)) {
        const evals = m.replace('$', '')
        try {
            e.player.directMessage('~>' + evals)
            e.player.directMessage('<~' + eval(evals))
        } catch (err) {
            e.player.directMessage(err)
        }
    } else if (m[0] == '/') {
        var cmd = m.substring(1).split(/\s+/);
        if (entity[cmd[0]] === undefined) {
            entity.player.directMessage('您的指令不存在或无效')
        } else {
            var params = cmd.slice(1, cmd.length);
            var paramIn = '';
            params.forEach((param) => {
                paramIn = isNumber(param) ? paramIn.concat(param, ',') : paramIn.concat(`'`, param, `'`, ',');
            })
            console.log(paramIn)
            paramIn.substring(0, params.length - 1);
            console.log(`entity.${cmd[0]}(${paramIn})`)
            eval(`entity[cmd[0]](${paramIn})`);
        }
    }
});
function find(n) { return world.querySelectorAll('player').filter(e => e.player.name === n)[0]; }
function isNumber(value) { var patrn = /^[0-9]*[1-9][0-9]*$/; if (patrn.exec(value) == null || value == "") { return false } else { return true } }

const commandList = ['msg:私聊', 'help:获取指令帮助', 'save:安全保存', 'fix:卡点脱离（慎用）']

            </code>
                                                </pre>
                                </div>
                            </div>
                        </div>
                        <div class="panel panel-default">
                            <div class="panel-heading">
                                <a class="panel-title collapsed" data-toggle="collapse" data-parent="#panel-586155"
                                    href="#panel-element1-6">NomenSQLite</a>
                            </div>
                            <div id="panel-element1-6" class="panel-collapse collapse">
                                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
                                        <p>index.js</p>
                                        <pre>
            <code class="language-js">
/**
 * !info {Project} -来自Nomen
 * NomenSQLite示例-玩家存档:介绍帖子https://shequ.codemao.cn/community/539624
 */



const NomenSQLite = require('./src.index.js').NomenSQLite;
const Tables = {
    'NomenSQLite': [//这是一个表格
        { name: 'userkey', type: NomenSQLite.DataType.TEXT, notnull: true }, // 这是一行数据，类型为TEXT，名字叫userKey，不能为空
        { name: 'bag', type: NomenSQLite.DataType.TEXT, notnull: false },
        { name: 'coin', type: NomenSQLite.DataType.NUMBER, notnull: false }
    ],
};


var NomenUser = null;
(async () => {
    //初始化并启动NomenSQLite
    let Nomen = await NomenSQLite.launch(Tables, NomenSQLite.LaunchAction.CREATE_OR_LAUNCH, (a, b) => { console.error(b) });

    //然后初始化NomenSQLite这个表格的管理器
    NomenUser = Nomen.operate('NomenSQLite');
})()

const BAG = []//玩家背包初始状态
const COIN = 0;//玩家金币初始状态

//当玩家进入的时候
world.onPlayerJoin(async ({ entity }) => {
    //如果数据库和NomenSQLite没有准备好就重试
    while (true) {
        if (NomenUser && NomenUser.select) break;
    }

    //读取玩家的数据，使用玩家唯一的userKey进行标识
    let result = await NomenUser.select('userkey', entity.player.userKey);

    //如果玩家存在存档
    if (result.length) {

        //将玩家的金币设置为存档中的金币
        entity.coin = result[0].coin;

        //将玩家的背包解析出来
        entity.bag = JSON.parse(result[0].bag);
    } else {
        //如果不存在存档，就插入一个新的存档
        await NomenUser.insert({
            userkey: entity.player.userKey, //玩家唯一标识符
            bag: JSON.stringify(BAG), //玩家背包
            coin: COIN //玩家金币
        })
    }
})

world.onPlayerLeave(({ entity }) => {
    //更新玩家云存档
    NomenUser.update(`userkey=${entity.player.userKey}`//使用userKey搜寻玩家的旧存档
        , {
            bag: JSON.stringify(entity.bag), //玩家背包
            coin: entity.coin //玩家金币
        })
})
            </code>
            </pre>
            <p>scr.index.js</p>
<pre>
            <code class="language-js">
/**
 * !info {Project} -来自Nomen
 * NomenSQLite:介绍帖子https://shequ.codemao.cn/wiki/forum/539617
 */



class NomenSQLite {
    constructor() {
        if (NomenSQLite.instance) return NomenSQLite.instance;
        NomenSQLite.instance = this;
    }
    static launched = false;
    static async launch(config, action, callback) {
        if (!config) throw new Error('请传入配置参数后重试');
        if (!this.instance) this.instance = new NomenSQLite();
        else return this.instance;
        this.tables = config || {};
        this._data = {};
        if (!Object.keys(this.tables).length) this._data = null;
        Object.keys(this.tables).forEach(v => {
            if (Array.isArray(this.tables[v]) && this.tables[v].length) {
                this._data[v] = [];
                this.tables[v].forEach(r => {
                    if (typeof r.name == "string" && Object.values(this.DataType).includes(r.type)) {
                        this._data[v].push({ name: r.name, type: r.type, notnull: r.notnull || false });
                    }
                })
            }
        })
        console.log(JSON.stringify(this._data));
        if (!Object.keys(this._data).length) return this.instance;
        let errMessage = null;
        if (typeof action == "string" && action.includes('create')) {
            for (let i = 0; i < Object.keys(this._data).length; i++) {
                let eString = `CREATE TABLE IF NOT EXISTS "${Object.keys(this._data)[i]}" 
                (${this._data[Object.keys(this._data)[i]].reduce((p, c) => {
                    let str = `"${c.name}" ${c.type} ${c.notnull ? 'NOT NULL' : ''}`;
                    return p ? p.concat(',', str) : str;
                }, false)})`;
                try { await this.instance._exec(eString); } catch (err) {
                    errMessage.concat(err);
                }
            }
        }
        this.launched = true;
        if (typeof callback == "function") callback(null, errMessage);
        return this.instance;
    }
    _exec(cmd) {
        return (typeof cmd == 'string') ? db.sql([cmd]) : new Promise(resolve => resolve(new TypeError('传入参数有误，预期应该为string')))
    }
    getAllTables() {
        return Object.keys(NomenSQLite._data);
    }
    async getAllTablesInDatabase() {
        return (await this._exec(`SELECT * FROM sqlite_master`)).map(v => v.name)
    }
    operate(name) {
        let t = this;
        if (typeof name == "string" && NomenSQLite.launched) return {
            select(column, value) {
                return t._exec(`SELECT * FROM "${name}" ${column == "*" ? `` : (`WHERE "${column}" = ` + (typeof value == "number") ? value : `"${value}"`)}`)
            },
            remove(column, value) {
                return t._exec(`DELETE FROM "${name}" ${column == "*" ? `` : (`WHERE "${column}" = ` + (typeof value == "number") ? value : `"${value}"`)}`)
            },
            insert(value) {
                if (Object.prototype.toString.call(value) == '[object Object]' && Object.keys(value).length) {
                    let eString = `(${Object.keys(value).map(v => `"${v}"`).join(',')}) VALUES(${Object.values(value).map(v => (typeof v == "number") ? v : `"${v}"`).join(',')})`;
                    return t._exec(`INSERT INTO "${name}" ${eString}`);
                } else return null;
            },
            update(column, value) {
                if (Object.prototype.toString.call(value) == '[object Object]' && Object.keys(value).length && typeof column == "string" && column.includes('=')) {
                    let eArr = [];
                    Object.entries(value).forEach(([k, v]) => eArr.push(`"${k}" = "${v}"`));
                    let aString = `${column == "*" ? "" : 'WHERE "' + column.split('=')[0] + '"="' + column.split('=')[1] + '"'}`;
                    console.log(`UPDATE "${name}" SET ${eArr} ${aString}`)
                    return t._exec(`UPDATE "${name}" SET ${eArr} ${aString}`);
                } else return null;
            }
        }
        return {};
    }
    static instance = null;
    static LaunchAction = {
        CREATE_OR_LAUNCH: 'createlaunch',
        LAUNCH: 'launch'
    }
    static DataType = {
        NUMBER: 'INTEGER',
        FLOAT: 'REAL',
        TEXT: 'TEXT',
        NULL: 'NULL',
        BLOB: 'BLOB'
    }
}

module.exports = {
    NomenSQLite
}

  
            </code>
                                                </pre>
                                </div>
                            </div>
                        </div>
                        <div class="panel panel-default">
                            <div class="panel-heading">
                                <a class="panel-title collapsed" data-toggle="collapse" data-parent="#panel-586155"
                                    href="#panel-element1-7">PG数据库</a>
                            </div>
                            <div id="panel-element1-7" class="panel-collapse collapse">
                                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
                                    <pre>
            <code class="language-js">
                /**
 * !info {Project} -来自网络
 * PG SQL 操作
 */



class message {
    constructor(state, inform) {
        return { state: state === true ? 'Succeeded' : 'Failed', inform: inform }
    }
}
const value = {
    coin: 100,
}
class sql {
    constructor(tableName, init) {
        this.tableName = tableName;
        this.initValues = init;
        this.initialized = false;
    }    
    async init() {
        if (this.initialized) return;
        try {
            if((await db.sql`SELECT * FROM ${this.tableName} WHERE id = system`).length){
                console.log(`===[ ${this.tableName} inited ]===`);
                this.initialized = true;
                return;
            }
            db.sql`CREATE TABLE IF NOT EXISTS ${this.tableName}(
                key CHAR(16) NOT NULL,
                value TEXT NOT NULL
            )`
            console.log(`===[ ${this.tableName} init succeeded ]===`)
            // var row=db.sql`SELECT * FROM ${this.tableName} WHERE key=system`
            // if(row && !row.length){
            //     var data=JSON.stringify({initialized:true,tableName:this.tableName})
            //     db.sql`INSERT INTO ${this.tableName} VALUES(system,data)`;
            // }
            this.initialized = true;
        } catch (error) {
            throw new Error(`===[ ${this.tableName} init failed ]===\n${error}`)
        }
    }
    async initPlayer(targetEntity) {
        if (!this.initialized) {console.log('TABLE did not INIT');return;};
        Object.assign(entity, this.initValues);
        if (!targetEntity.player.userKey) return;
        const values = await db.sql`SELECT * FROM ${this.tableName} WHERE id = ${targetEntity.player.userKey}`;
        if (rows && !rows.length) {
            db.sql`INSERT INTO ${this.tableName} VALUES(${targetEntity.player.userKey},${value})`;
        } else {
            Object.assign(targetEntity, JSON.parse(values[0].value));
        }
    }
    async ALL() {
        if (!this.initialized) {console.log('TABLE did not INIT');return;};
        console.warn(`db.sql'SELECT * FROM ${this.tableName}'`)
        for await (const rows of db.sql`SELECT * FROM ${this.tableName}`) {//${this.tableName}
            // row.then((ele)=>{
            //     console.log(ele.key,":",JSON.parse(ele.value))
            // })
        }
    }
    async DROP() {
        // if (!this.initialized) {console.log('TABLE did not INIT');return;};
        await db.sql`DELETE FROM ${this.tableName}`;
        this.initialized = false;
    }
}



global.DB = {
    async poll() {
        while (true) {
            try {
                await db.sql`select 1;`
                break
            } catch (e) {
                world.say('pg数据库启动中...')
            }
            await sleep(1000)
        }
    },
    async insert(tbName, dict, key) {
        const keyList = Object.keys(dict)
        const valList = Object.values(dict).map((v, i) => {
            if (v.constructor === Array || v.constructor === Object) {
                return JSON.stringify(v)
            }
            return v
        })
        let cmd
        if (key) {
            cmd = [`INSERT INTO ${tbName} (${keyList})VALUES(`, ...(','.repeat(keyList.length - 1)), `) ON CONFLICT (${key}) DO NOTHING;`]
        } else {
            cmd = [`INSERT INTO ${tbName} (${keyList})VALUES(`, ...(','.repeat(keyList.length - 1)), `);`]
        }
        while (true) {
            try {
                return await db.sql(cmd, ...valList)
            } catch (e) {
                world.say(e.stack)
            }
            await sleep(300)
        }
    },
    async upsert(tbName, dict, key = 'userkey') {
        const keyList = Object.keys(dict)
        const valList = Object.values(dict).map((v, i) => {
            if (v.constructor === Array || v.constructor === Object) {
                return JSON.stringify(v)
            }
            return v
        })
        const cmd = [`INSERT OR REPLACE INTO ${tbName} (${keyList})VALUES(`, ...(','.repeat(keyList.length - 1)), `) ON CONFLICT (${key}) DO NOTHING;`]

        try {
            return await db.sql(cmd, ...valList)
        } catch (e) {
            world.say(e.stack + '\n' + cmd + '\n' + valList)
        }
    },
    async update(tbName, key, dict) {
        let id = dict[key]
        delete dict[key]
        let keyList = Object.keys(dict)
        const valList = Object.values(dict)
        let head = keyList.shift()
        let tail = keyList.map((e, i) => `,${e}=`)
        const cmd = [`UPDATE ${tbName} SET ${head}=`, ...tail, ` WHERE ${key}=`, ';']
        return await db.sql(cmd, ...valList, id)
    },
    async updateAll(tbName, dict) {
        let keyList = Object.keys(dict)
        const valList = Object.values(dict)
        let head = keyList.shift()
        let tail = keyList.map((e, i) => `,${e}=`)
        const cmd = [`UPDATE ${tbName} SET ${head}=`, ...tail, ';']
        return await db.sql(cmd, ...valList)
    },
    async del(tbName, cond) {
        const cmd = [`DELETE FROM ${tbName} WHERE ${cond};`]
        try {
            return await db.sql(cmd)
        } catch (e) {
            world.say(e.stack + '\n@' + cmd + '\n#' + cond)
        }
    },
    async find(tbName, cond) {
        cond = cond ? `WHERE ${cond}` : ''
        const cmd = [`SELECT * FROM ${tbName} ${cond} LIMIT 1;`]
        try {
            return (await db.sql(cmd))[0]
        } catch (e) {
            world.say(e.stack + '\n@' + cmd + '\n#' + cond)
        }
    },
    async findAll(tbName, cond) {
        cond = cond ? `WHERE ${cond}` : ''
        const cmd = [`SELECT * FROM ${tbName} ${cond};`]
        try {
            return await db.sql(cmd)
        } catch (e) {
            world.say(e.stack + '\n@' + cmd + '\n#' + cond)
        }
    },
    async drop(tbName) {
        const cmd = [`DROP TABLE ${tbName}`]
        return await db.sql(cmd)
    },
    async count(tbName) {
        const cmd = [`SELECT COUNT(*) FROM ${tbName}`]
        const out = (await db.sql(cmd))[0]['count']
        try {
            return out
        } catch (e) {
            world.say(e.stack)
        }
    },
    async table(tbName, dict) {
        const cmd = [`CREATE TABLE IF NOT EXISTS ${tbName} (${Object.entries(dict).map(([k, v]) => `${k} ${v}`).join(',')});`]
        try {
            return await db.sql(cmd)
        } catch (e) {
            world.say(e.stack)
        }
    },
    async rank(tbName, col, where, lim = 100, ord = 'desc') {
        const cond = where ? `WHERE ${where} ` : ''
        const cmd = [`SELECT * FROM ${tbName} ${cond} ORDER BY ${col} ${ord} LIMIT ${lim};`]
        try {
            return await db.sql(cmd)
        } catch (e) {
            world.say(e.stack)
        }
    },
    async savePlayer(user, ...keyList) {
        if (user.isGuest()) return
        const data = user.data
        const valList = keyList.map(e => {
            const v = data[e]
            if (v.constructor === Array || v.constructor === Object) {
                return JSON.stringify(v)
            } else if (v.constructor === Number) {
                return v
            }
            return v
        })
        let head = keyList.shift()
        let tail = keyList.map((e, i) => `,${e}=`)
        const cmd = [`UPDATE player SET ${head}=`, ...tail, ` WHERE userkey=`, '']
        while (true) {
            try {
                return await db.sql(cmd, ...valList, user.player.userKey)
            } catch (e) {
                world.say(e.stack + '\n@' + cmd + '\n#' + valList)
            }
            await sleep(300)
        }
    },
    async loadPlayer(user, list) {
        const userKey = user.player.userKey
        while (true) {
            try {
                const data = (await (db.sql`SELECT * FROM player WHERE userkey=${userKey}`))[0]
                if (data) {
                    for (const k of list) {
                        data[k] = JSON.parse(data[k])
                    }
                    user.data = data
                    return true
                }
                return false
            } catch (e) {
                world.say(e.stack)
            }
            await sleep(300)
        }
    },
}

async function initDB() {
    await DB.poll()
    await DB.table('record', {
        time: "int not null",
        boss: "varchar(30) default ''",
        result: 'int default 0',
        catSoldier: 'int default 0',
        spiderSoldier: 'int default 0',
        mentaSoldier: 'int default 0',
        buboSoldier: 'int default 0',
    })
    // 加新字段
    try {
        await db.sql`ALTER TABLE record ADD rhinoSoldier  int default 0`
    } catch (e) {
        console.log(e)
    }
}
initDB()

            </code>
                                                </pre>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
</body>

</html>