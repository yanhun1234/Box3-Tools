<!DOCTYPE html>
<html>

<head>
    <title>BOX3-Tools</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/3.3.7/css/bootstrap.min.css">
    <script src="https://cdn.staticfile.org/jquery/2.1.1/jquery.min.js"></script>
    <script src="https://cdn.staticfile.org/twitter-bootstrap/3.3.7/js/bootstrap.min.js"></script>
    <style>
        #cnblogs_post_body .cnblogs_code {
            /* background-color: rgba(152, 147, 147, 0.28); */
            /* border: 1px solid rgba(255, 251, 251, 0); */
            border-radius: 4px;
            color: #000;
            font-family: Courier New !important;
            font-size: 13px !important;
            margin: 5px 0;
            overflow: auto;
            padding: 5px;
        }

        .hljs-built_in,
        .hljs-keyword,
        .hljs-name,
        .hljs-selector-tag,
        .hljs-tag {
            color: #332870 !important;
        }

        .hljs-emphasis,
        .hljs-strong {
            color: #a8a8a2 !important;
        }

        .hljs-built_in,
        .hljs-keyword,
        .hljs-name,
        .hljs-selector-tag,
        .hljs-tag {
            color: #bababa !important;
        }

        .hljs-bullet,
        .hljs-link,
        .hljs-literal,
        .hljs-number,
        .hljs-quote,
        .hljs-regexp {
            color: #27c94a !important;
        }

        .hljs-code,
        .hljs-selector-class {
            color: #eeff00 !important;
        }

        .hljs-emphasis {
            font-style: italic !important;
        }

        .hljs-attribute,
        .hljs-keyword,
        .hljs-name,
        .hljs-section,
        .hljs-selector-tag,
        .hljs-variable {
            color: #00c3ff !important;
        }

        .hljs-attr,
        .hljs-params {
            color: #b9b9b9 !important;
        }

        .hljs-string {
            color: #ffbb00 !important;
        }

        .hljs-addition,
        .hljs-built_in,
        .hljs-builtin-name,
        .hljs-selector-attr,
        .hljs-selector-id,
        .hljs-selector-pseudo,
        .hljs-subst,
        .hljs-symbol,
        .hljs-template-tag,
        .hljs-template-variable,
        .hljs-title,
        .hljs-type {
            color: #dfe231 !important;
        }

        .hljs-comment,
        .hljs-deletion {
            color: #008839 !important;
        }

        .hljs-meta {
            color: #00ff0d !important;
        }

        #cnblogs_post_body .toc ul {
            max-height: 550px;
            overflow-y: auto;
        }

        .cnblogs-markdown .hljs {
            display: block;
            overflow-x: auto;
            padding: 0.5em !important;
            background: #2b2b2b !important;
            font-size: 14px !important;
            color: #bababa !important;
            font-family: Source Code Pro, Consolas, Menlo, Monaco, Courier New,
                monospace !important;
        }

        #cnblogs_post_body h1::before {
            content: "H1";
            margin-right: 10px;
            color: gainsboro;
        }

        #cnblogs_post_body h2::before {
            content: "H2";
            margin-right: 10px;
            color: gainsboro;
        }

        #cnblogs_post_body h3::before {
            content: "H3";
            margin-right: 10px;
            color: gainsboro;
        }

        #mainContent #post_detail #cnblogs_post_body h4::before {
            content: "h4";
            margin-right: 10px;
            color: gainsboro;
        }

        #cnblogs_post_body h5::before {
            content: "h5";
            margin-right: 10px;
            color: gainsboro;
        }

        #cnblogs_post_body h6::before {
            content: "h6";
            margin-right: 10px;
            color: gainsboro;
        }

        #cnblogs_post_body td.hljs-ln-numbers {
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;

            text-align: center;
            color: #ccc;
            border-right: 1px solid #ccc;
            vertical-align: top;
            padding-right: 5px;

            /* your custom style here */
        }

        #cnblogs_post_body .hljs td {
            border-collapse: inherit;
            min-width: unset;
            padding-left: 20px;
            padding-right: 10px;
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="row clearfix">
            <div class="col-md-12 column">
                <h3 class="text-center">
                    BOX3-Tools主页面
                </h3>
            </div>
        </div>
        <div class="panel-group" id="panels-1">
            <div class="panel panel-default">
                <div class="panel-heading">
                    <a class="panel-title collapsed" data-toggle="collapse" data-parent="#panels-1"
                        href="#panel-element-1">官方教程</a>
                </div>
                <div id="panel-element-1" class="panel-collapse collapse">
                    <div class="panel-body">
                        <div class="row clearfix">
                            <div class="col-md-12 column">
                                <blockquote>
                                    <h2>
                                        官方教程
                                    </h2>
                                </blockquote>
                                <div class="panel-group" id="panel-586155">
                                    <div class="panel panel-default">
                                        <div class="panel-heading">
                                            <a class="panel-title collapsed" data-toggle="collapse"
                                                data-parent="#panel-586155" href="#panel-element-1">变成模型+自定义出生点</a>
                                        </div>
                                        <div id="panel-element-1" class="panel-collapse collapse">
                                            <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
                                                <pre>
            <code class="language-js">
              /**
 * !info {Project} -来自(shequ.codemao.cn/community/371088)@吉吉喵
 * 有不少同学都在问的代码教程来咯！
 * 分别是让自己变成模型的样子
 * 以及自定义出生点！
 */



// 1.变成模型
for (const e of world.querySelectorAll('*')) {
    e.collides = true //实体可以被碰撞
    e.fixed = true //实体固定位置
    e.onEntityContact(({ other }) => {
        if (other.isPlayer) { // 如果跟当前实体碰撞的是玩家实体
            e.destroy()  //当前实体消失
            other.player.invisible = true // 玩家皮肤隐藏
            other.mesh = e.mesh // 玩家的外形换成当前实体的外形
            other.meshScale.copy(e.meshScale) // 玩家外形的缩放比例设成跟当前实体一样
            other.player.scale = e.meshScale.scale(e.bounds.y / other.bounds.y) //喵家的隐形碰撞盒缩放到模型刚好贴地
        }
    })
}


// 如果模型的朝向有问题
// 那么就要修正一下方向：
const Quat = new Box3Quaternion(0, 0, 0, 1)
for (const e of world.querySelectorAll('*')) {
    e.collides = true
    e.fixed = true
    e.onEntityContact(({ other }) => {
        if (other.isPlayer) { // 如果跟当前实体碰撞的是玩家实体
            other.player.invisible = true // 玩家皮肤隐藏
            other.mesh = e.mesh // 玩家的外形换成当前实体的外形
            other.meshScale.copy(e.meshScale) // 玩家外形的缩放比例设成跟当前实体一样

            //如果模型方向不正确, 则建议在模型编辑器里把模型转向修正

            // 也可以尝试下面其中一行代码, 但不同的模型需要转的角度不同, 无法通用
            // other.meshOrientation = Quat.rotateY(Math.PI) // 如果模型方向不对, 尝试旋转180度来修正, Math.PI是180度的弧度值
            // other.meshOrientation = Quat.rotateY(Math.PI/2) // 如果模型方向不对, 尝试旋转90度来修正
            // other.meshOrientation = Quat.rotateY(-Math.PI/2) // 如果模型方向不对, 尝试旋转-90度来修正

            other.player.scale = e.meshScale.scale(e.bounds.y / other.bounds.y) //喵家的隐形碰撞盒缩放到模型刚好贴地
        }
    })
}



// 2.自定义出生点

// 在某个坐标出生的4种写法：  
world.onPlayerJoin(({entity})=>{
    entity.player.spawnPoint.set(4, 11, 4)
    entity.player.forceRespawn()
})
world.onPlayerJoin(({entity})=>{
    entity.player.spawnPoint.set(4, 11, 4)
    entity.position.copy(entity.player.spawnPoint)
})
world.onPlayerJoin(({entity})=>{
    entity.player.spawnPoint = new Box3Vector3(4, 11, 4)
    entity.player.forceRespawn()
})
world.onPlayerJoin(({entity})=>{
    entity.player.spawnPoint = new Box3Vector3(4, 11, 4)
    entity.position.copy(entity.player.spawnPoint)
})

// 在某个模型的位置出生：
world.onPlayerJoin(({entity})=>{
    entity.player.spawnPoint = world.querySelector('#出生点').position
    entity.position.copy(entity.player.spawnPoint)
    entity.position.y += 10
})
            </code>
        </pre>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="panel panel-default">
                                        <div class="panel-heading">
                                            <a class="panel-title collapsed" data-toggle="collapse"
                                                data-parent="#panel-586155" href="#panel-element-2">吃了蘑菇会变身</a>
                                        </div>
                                        <div id="panel-element-2" class="panel-collapse collapse">
                                            <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
                                                <pre>
            <code class="language-js">
              /**
 * !info {Project} -来自(shequ.codemao.cn/community/417036)@吉吉喵
 * 相信大家都玩了B站up主火山giegie做的《3D超级马里奥》了吧
 * （没玩过的迅速去玩！搭配视频享用更美味）
 * 本期教程的主题就是用道具改变属性
 * 让你“变大变小变无敌”～
 */



// 跳跃道具
// 获取场景中的“弹簧”实体，作为跳跃道具
const jumpProp = world.querySelector('#弹簧-1')
// 为了下面方便使用，将实体命名为 跳跃道具
jumpProp.id = "跳跃道具"
// 开启道具的实体碰撞
jumpProp.collides = true

// 加速道具
// 获取场景中的“西瓜”实体，作为加速道具
const speedProp = world.querySelector('#MC西瓜-1')
// 为了下面方便使用，将实体命名为 加速道具
speedProp.id = "加速道具"
// 开启道具的实体碰撞
speedProp.collides = true

// 罚站道具
// 获取场景中的“陷阱”实体，作为罚站道具
const trapProp = world.querySelector('#陷阱-1')
// 为了下面方便使用，将实体命名为 罚站道具
trapProp.id = "罚站道具"
// 开启道具的实体碰撞
trapProp.collides = true

// 隐身道具
// 获取场景中的“隐身卡”实体，作为隐身道具
const invisibleProp = world.querySelector('#隐身技能卡-1')
// 为了下面方便使用，将实体命名为 隐身道具
invisibleProp.id = "隐身道具"
// 开启道具的实体碰撞
invisibleProp.collides = true

// 当实体与实体发生碰撞时
world.onEntityContact(async ({ entity, other }) => {
    // 首先需要判断当前碰撞的实体是玩家类型的实体触发的
    if (entity && entity.isPlayer) {
        // 由于onEntityContact事件会因为两个实体碰撞而触发，
        // 因此，当我们确定了其中一个是“玩家”类型的实体之后(entity.isPlayer)
        // 另一个实体other 便是我们要判断的实体道具
        // 接下来会根据实体类型的不同，区分碰撞到之后对玩家产生的效果

        // 如果玩家碰到的是加速道具，那么我们希望玩家可以获得一个加速效果
        // 要对玩家的移动进行加速，可以通过修改玩家的：行走速度、行走加速度、跑步速度以及跑步加速度来实现
        if (other.id === "加速道具") {
            // 加速道具被碰到之后就删除掉它(这样才像被玩家"吃掉"了)
            other.destroy()
            // 行走速度默认为0.22，这里设置为2倍的速度
            entity.player.walkSpeed = 0.44
            // 行走加速度默认为0.19，这里设置为2倍的速度
            entity.player.walkAcceleration = 0.38
            // 跑步速度默认为0.4，这里设置为2倍的速度
            entity.player.runSpeed = 0.8
            // 跑步加速度默认为0.35，这里设置为2倍的速度
            entity.player.runAcceleration = 0.7

            entity.player.directMessage(`你获得了奔跑加速！`)

            // 设置定时器，定时时间为5000毫秒(5秒)，5秒后会触发定时器内的代码
            setTimeout(() => {
                // 将玩家的移动和跑步速度复原
                entity.player.walkSpeed = 0.22
                entity.player.walkAcceleration = 0.19
                entity.player.runSpeed = 0.4
                entity.player.runAcceleration = 0.35
            }, 5000);
        }

        // 如果玩家碰到的是跳跃道具，那么我们希望玩家可以获得一个向上跳跃的效果
        if (other.id === "跳跃道具") {
            other.destroy()
            // 设置玩家的跳跃力度为原本的两倍
            entity.player.jumpPower = 0.96 * 2

            entity.player.directMessage(`你获得了跳跃加成！`)

            // 设置定时器，定时时间为5000毫秒(5秒)，5秒后会触发定时器内的代码
            setTimeout(() => {
                // 将玩家的跳跃力度复原
                entity.player.jumpPower = 0.96
            }, 5000);
        }

        // 如果玩家碰到的是罚站道具，那么我们希望玩家完全不能移动
        if (other.id === "罚站道具") {
            other.destroy()
            // 参考“加速道具”的实现方式，只要我们喵家的行走速度、行走加速度、跑步速度以及跑步加速度都设置为0
            // 玩家就没办法走路和跑步了
            entity.player.walkSpeed = 0
            entity.player.walkAcceleration = 0

            entity.player.runSpeed = 0
            entity.player.runAcceleration = 0
            // 顺便喵家的“跳跃”给关闭了，这样一来玩家不但不能走和跑，也不能跳了
            entity.player.enableJump = false

            entity.player.directMessage(`你撞到了陷阱，暂时无法行动！`)

            // 设置定时器，定时时间为5000毫秒(5秒)，5秒后会触发定时器内的代码
            setTimeout(() => {
                // 将玩家的移动和跑步速度复原
                entity.player.walkSpeed = 0.22
                entity.player.walkAcceleration = 0.19
                entity.player.runSpeed = 0.4
                entity.player.runAcceleration = 0.35
                // 将玩家的跳跃设置打开
                entity.player.enableJump = true
            }, 5000);
        }

        // 如果玩家碰到的是隐身道具，那么我们希望玩家隐身不可见
        if (other.id === "隐身道具") {
            other.destroy()
            // 隐藏所有身体部件
            for (const bodyPart in entity.player.skinInvisible) {
                entity.player.skinInvisible[bodyPart] = true;
            }

            entity.player.directMessage(`你获得了隐身效果！`)

            // 设置定时器，定时时间为5000毫秒(5秒)，5秒后会触发定时器内的代码
            setTimeout(() => {
                // 显示所有身体部件
                for (const bodyPart in entity.player.skinInvisible) {
                    entity.player.skinInvisible[bodyPart] = false;
                }
            }, 5000);
        }
    }
})
            </code>
        </pre>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="panel panel-default">
                                        <div class="panel-heading">
                                            <a class="panel-title collapsed" data-toggle="collapse"
                                                data-parent="#panel-586155" href="#panel-element-3">宠物跟随</a>
                                        </div>
                                        <div id="panel-element-3" class="panel-collapse collapse">
                                            <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
                                                <pre>
            <code class="language-js">
              /**
 * !info {Project} -来自(shequ.codemao.cn/community/378184)@吉吉喵
 * 想拥有一只独一无二的跟随宠物吗？
 * 想成为《学习吧！小精灵》里的被精灵环绕的大神吗？
 * 学会这招，你就是岛上最靓的崽～
 */



console.clear()
const mscale = 1 / 16
const Quat = new Box3Quaternion(0, 0, 0, 1)

function buddyFollow(entity, mesh, y) {
    const buddy = world.createEntity({
        mesh,
        position: entity.position,
        meshScale: [mscale, mscale, mscale],
        gravity: false, //不受重力影响
        fixed: false, //可推移
        collides: true, //可碰撞
        friction: 0, //无摩擦力
        mass: 0.01, //非常轻
    })

    const tgPos = entity.position//僚机的目标位置
    const budPos = buddy.position//僚机的当前位置
    const facing = entity.player.facingDirection//玩家的朝向
    const ratio = 0.3//追随的灵敏度, 最好设在0.5左右, 1.0表示立即移到玩家位置

    const dist = 2 //与玩家保持的距离
    const yOffset = y //y轴位移, 保持僚机在头顶或脚下

    const ticker = world.onTick(() => {

        //要让小精灵跟在玩家背后, 需要计算xz轴的位移: 玩家朝向的反方向
        const xOffset = -facing.x * dist
        const zOffset = -facing.z * dist

        //当前位置与目标位置在xyz轴的差距
        const xDiff = tgPos.x - budPos.x
        const yDiff = tgPos.y - budPos.y
        const zDiff = tgPos.z - budPos.z

        //计算xyz方向上 当前位置向目标位置靠拢的速度
        const 喵 = (xDiff + xOffset) * ratio
        const vy = (yDiff + yOffset) * ratio
        const vz = (zDiff + zOffset) * ratio

        buddy.velocity.set(喵, vy, vz)//设置僚机速度

        if (buddy.velocity.sqrMag() > 0.005) {//速度要足够大, 才触发转向, 防止抖动
            buddy.meshOrientation = Quat.rotateY(Math.atan2(zDiff, xDiff)) //让小精灵一直面向玩家
        }
    })

    return () => {
        ticker.cancel() //关掉tick循环
        buddy.destroy() //移除僚机实体
    }
}

world.onPlayerJoin(({ entity }) => {
    entity.setPet = buddyFollow(entity, 'mesh/皮卡丘.vb', -1) //给玩家增加宠物
})

world.onPlayerLeave(({ entity }) => {
    //玩家离开地图时, 切记一定要关掉tick循环以及销毁小精灵实体, 否则随着人数增加, 服务器积累到一定程度就会崩溃
    entity.setPet() //干掉宠物
})
            </code>
        </pre>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="panel panel-default">
                                        <div class="panel-heading">
                                            <a class="panel-title collapsed" data-toggle="collapse"
                                                data-parent="#panel-586155" href="#panel-element-4">传送门</a>
                                        </div>
                                        <div id="panel-element-4" class="panel-collapse collapse">
                                            <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
                                                <pre>
            <code class="language-js">
              /**
 * !info {Project} -来自(shequ.codemao.cn/community/358096)@吉吉喵
 * player.link里的是要传送的地图的地址
 * 这里喵喵用了entiy.onInteract的API
 * 所以按E就可以执行传送
 * 但是你们可以用其他的方式哦
 * 比如发送一串字符传送等等
 * 还等你来发掘～
 */



console.clear()
var door = world.querySelector('#门')

door.enableInteract = true
door.interactRadius = 2.5

door.onInteract(({ entity }) => {
    entity.player.link('https://box3.codemao.cn/p/6a4e57e1f91817445b21')
})
            </code>
        </pre>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="panel panel-default">
                                        <div class="panel-heading">
                                            <a class="panel-title collapsed" data-toggle="collapse"
                                                data-parent="#panel-586155" href="#panel-element-5">传送至地图的指定地点</a>
                                        </div>
                                        <div id="panel-element-5" class="panel-collapse collapse">
                                            <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
                                                <pre>
            <code class="language-js">
              /**
 * !info {Project} -来自(shequ.codemao.cn/community/359895)@吉吉喵
 * 上一期我们学习了传送教程
 * 这期的小技巧是进阶版传送门
 * 教你传送到地图上任意的位置！
 */



console.clear()
var door = world.querySelector('#传送门')
door.enableInteract = true
door.interactRadius = 2
door.interactHint = '传送到瀑布上面'

door.onInteract(({ entity }) => {
    entity.position.set(61,94,46)
})


/* 或 */

console.clear()

var door1 = world.querySelector('#红门')
door1.enableInteract = true
door1.interactRadius = 2.5

var door2 = world.querySelector('#绿门')
door2.enableInteract = true
door2.interactRadius = 2.5

var door3 = world.querySelector('#蓝门')
door3.enableInteract = true
door3.interactRadius = 2.5

door1.onInteract(({ entity }) => {
    entity.position.copy(door2.position)
})

door2.onInteract(({ entity }) => {
    entity.position.copy(door3.position)
})

door3.onInteract(({ entity }) => {
    entity.position.copy(door1.position)
})

            </code>
        </pre>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="panel panel-default">
                                        <div class="panel-heading">
                                            <a class="panel-title collapsed" data-toggle="collapse"
                                                data-parent="#panel-586155" href="#panel-element-6">大范围伤害</a>
                                        </div>
                                        <div id="panel-element-6" class="panel-collapse collapse">
                                            <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
                                                <pre>
            <code class="language-js">
               /**
 * !info {Project} -来自(shequ.codemao.cn/community/377745)@吉吉喵
 * AOE，强力有效的范围性技能
 * 能够作用于多个目标
 * 是游戏中居家旅行打架必备之技能
 * 今天喵师傅就传你这招！
 */



console.clear()

const mscale = 1 / 16
const n = [-4, -3, -2, -1, 0, 1, 2, 3, 4]

// 生成一堆小人
for (let x of n) {
    for (let y of n) {
        for (let z of n) {
            const e = world.createEntity({
                mesh: 'mesh/小人.vb',
                fixed: true,
                collides: false,
                position: [x * 4 + 64, y * 3 + 16, z * 4 + 64],
                meshScale: [mscale, mscale, mscale],
            })
            e.enableDamage = true
            e.onDie(() => {
                e.destroy()
            })
        }
    }
}

world.onPlayerJoin(({ entity }) => {
    entity.enableDamage = true 
})


function killZone(pos, radius, fn) { //球状AOE
    for (const e of world.querySelectorAll('*')) {//遍历所有实体
        const dist = e.position.distance(pos)//计算作用点与当前实体的距离
        if (dist <= radius) {//当距离小于等于有效作用半径
            fn(e, dist)//传递当前实体和距离到回调函数并执行
        }
    }
}

async function killBox(pos, size, fn) { //盒状AOE
    //搜索包围盒内的所有实体
    const entities = world.searchBox({
        lo: [pos.x - size, pos.y - size, pos.z - size], //包围盒下边界
        hi: [pos.x + size, pos.y + size, pos.z + size], //包围盒上边界
    })

    for (const e of entities) { //遍历所有找到的实体
        fn(e)
    }
}

async function makeDamage(e, dmg, color) {
    e.hurt(Math.max(1, dmg)) //max用于防止负数伤害

    e.meshColor.copy(color) //当前实体变色
    await sleep(500)
    e.meshColor.set(1, 1, 1, 1) //恢复正常颜色
}

const RED = new Box3RGBAColor(1, 0, 0, 1)
const GREEN = new Box3RGBAColor(0, 1, 0, 1)
const BLUE = new Box3RGBAColor(0, 0, 1, 1)
world.onPress(({ entity, button, raycast }) => {
    if (button === Box3ButtonType.CROUCH) { //下蹲键触发自身球状AOE
        const range = 8//AOE有效作用半径
        killZone(entity.position, range, async (e, dist) => {
            if (e === entity) return//如果当前实体是AOE施放者, 就不继续执行, 避免伤到自己
            const ratio = (range - dist) / range //计算距离百分比, 离得越近ratio越趋向1, 离得越远ratio越趋向0
            makeDamage(e, 100 * ratio, RED)
        })
    }
    else if (button === Box3ButtonType.ACTION0) { //左键触发远距离球状AOE
        const range = 8//AOE有效作用半径
        killZone(raycast.hitPosition, range, async (e, dist) => {
            if (e === entity) return//如果当前实体是AOE施放者, 就不继续执行, 避免伤到自己
            const ratio = (range - dist) / range //计算距离百分比, 离得越近ratio越趋向1, 离得越远ratio越趋向0
            makeDamage(e, 100 * ratio, GREEN)
        })
    }
    else if (button === Box3ButtonType.ACTION1) { //右键触发远距离盒状AOE
        const size = 7 //AOE盒的大小
        killBox(raycast.hitPosition, size, (e) => {
            if (e === entity) return//如果当前实体是AOE施放者, 就不继续执行, 避免伤到自己
            makeDamage(e, 20, BLUE)
        })
    }
})
            </code>
        </pre>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="panel panel-default">
                                        <div class="panel-heading">
                                            <a class="panel-title collapsed" data-toggle="collapse"
                                                data-parent="#panel-586155" href="#panel-element-7">弹跳装置和加速器</a>
                                        </div>
                                        <div id="panel-element-7" class="panel-collapse collapse">
                                            <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
                                                <pre>
            <code class="language-js">
             /**
 * !info {Project} -来自(shequ.codemao.cn/community/373142)@吉吉喵
 * 作为岛上最受欢迎的游戏类型
 * 跑酷是很多萌新都会选择的玩法
 * 除了存档功能之外
 * 吉吉喵今天再教你两招
 * 让你的跑酷地图与众不同！
 */



// 弹射板代码：
const pad = world.querySelector('#弹射跳板-1')
pad.onEntityContact(({ other, axis }) => {
    if (axis.y === -1) { // 如果是往下踩
        other.velocity.y = 2 // 设置玩家的瞬时y轴速度为2
    }
})



// 加速带代码：
const speedBump = world.querySelector('#加速带-1')
speedBump.onEntityContact(async ({ other }) => {
    if (other.isPlayer) {
        if (other.speedUp) {
            return //如果已经在加速中就不再加速
        }
        other.speedUp = true

        //记住正常的速度
        const oldSpeed = other.player.runSpeed
        const oldAccel = other.player.runAcceleration

        //双倍速度
        other.player.runSpeed *= 2
        other.player.runAcceleration *= 2

        await sleep(1000) // 等待一秒

        //恢复正常速度
        other.player.runSpeed = oldSpeed
        other.player.runAcceleration = oldAccel

        other.speedUp = false
    }
})
            </code>
        </pre>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="panel panel-default">
                                        <div class="panel-heading">
                                            <a class="panel-title collapsed" data-toggle="collapse"
                                                data-parent="#panel-586155" href="#panel-element-8">点击建造或者摧毁方块</a>
                                        </div>
                                        <div id="panel-element-8" class="panel-collapse collapse">
                                            <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
                                                <pre>
            <code class="language-js">
              /**
 * !info {Project} -来自(shequ.codemao.cn/community/368401)@吉吉喵
 * -生成山丘的代码-
 */



// 1.点击鼠标摧毁方块

world.onPlayerJoin(({ entity }) => {
    entity.player.enable3DCursor = true // 开启方块光标
})

world.onPress(({ raycast, button }) => {
    if (button === Box3ButtonType.ACTION0) {
        const pos = raycast.voxelIndex // 射线指到的方块位置
        voxels.setVoxel(pos.x, pos.y, pos.z, '')
    }
})



// 2.点击鼠标建造方块

world.onPlayerJoin(({ entity }) => {
    entity.player.enable3DCursor = true // 开启方块光标
})

world.onPress(({ raycast, button }) => {
    if (button === Box3ButtonType.ACTION0) {
        const pos = raycast.voxelIndex.add(raycast.normal) // 射线指到的方块位置加上被选中的面的法线向量
        voxels.setVoxel(pos.x, pos.y, pos.z, 'stone')
    }
})



// 3.点击鼠标切换方块

const voxelList = ['stone', 'dirt', 'grass', 'lava01'] // 可选方块

world.onPlayerJoin(({ entity }) => {
    entity.selected = 0 // 当前选定方块的序号
    entity.player.enable3DCursor = true // 开启方块光标
})

world.onPress(({ entity, raycast, button }) => {
    if (button === Box3ButtonType.ACTION0) {
        const vox = voxelList[entity.selected]
        const pos = raycast.voxelIndex.add(raycast.normal) // 射线指到的方块位置加上被选中的面的法线向量
        voxels.setVoxel(pos.x, pos.y, pos.z, vox)
    }
    else if (button === Box3ButtonType.ACTION1) {
        entity.selected = (entity.selected + 1) % voxelList.length
        const vox = voxelList[entity.selected]
        entity.player.directMessage(`当前选定"${vox}"`)
    }
})



// 3.点击鼠标切换方块

world.onPlayerJoin(({ entity }) => {
    entity.selected = 0 // 当前选定方块的序号
    entity.player.enable3DCursor = true // 开启方块光标
})

world.onPress(({ entity, raycast, button }) => {
    if (button === Box3ButtonType.ACTION0) {
        const vox = voxelList[entity.selected]
        const pos = raycast.voxelIndex.add(raycast.normal) // 射线指到的方块位置加上被选中的面的法线向量
        voxels.setVoxel(pos.x, pos.y, pos.z, vox)
    }
    else if (button === Box3ButtonType.ACTION1) {
        entity.selected = (entity.selected + 1) % voxelList.length
        const vox = voxelList[entity.selected]
        entity.player.directMessage(`当前选定"${vox}"`)
    }
})
            </code>
        </pre>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="panel panel-default">
                                        <div class="panel-heading">
                                            <a class="panel-title collapsed" data-toggle="collapse"
                                                data-parent="#panel-586155" href="#panel-element-9">多重对话之术</a>
                                        </div>
                                        <div id="panel-element-9" class="panel-collapse collapse">
                                            <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
                                                <pre>
            <code class="language-js">
              /**
 * !info {Project} -来自(shequ.codemao.cn/community/437424)@(恶.管)tiger666250
 * 多重对话之术！
 * 地图需包含两个npc模型
 * 与A对话（弹窗）后会接到与B对话的任务
 * 在与B对话完成任务后回来和A互动
 * 将会触发不同的对话内容
 */



console.clear()
async function text(entity, title, content) {//将一个text封装成函数，调用时更加的简单
    return await entity.player.dialog({
        type: Box3DialogType.TEXT,//text
        title,//标题
        content//内容
    })
}
//正片开始
for (const npc of world.querySelectorAll('.npc')) {//在地图中找到所有有npc标签的实体
    npc.enableInteract = true;//你可以和npc互动
    npc.interactRadius = 5;//互动范围为5
    npc.interactHint = npc.id//实体名称为模型的id
    if (npc.id == '吉吉喵') {//如果他是吉吉喵
        npc.onInteract(async ({ entity }) => {//判断互动
            if (entity.jq == 1) {//如果剧情变量为1时，应该让吉吉喵给玩家布置任务
                //以下是剧情
                text(entity, '吉吉喵', `${entity.player.name}，我做好了一碗鸡汤，快去给雷电猴吃吧！`)
                text(entity, '吉吉喵', `把鸡汤给了雷电猴后就过来报道哦~`)
                text(entity, '吉吉喵', `任务1：把鸡汤给雷电猴`)
                entity.player.directMessage('你获得了一碗 鸡汤')
                //变量调整，让玩家去找雷电猴
                entity.jq = 2;
            } else if (entity.jq == 2) {//如果剧情变量为2时，吉吉喵没有需要干的事情，但是为了使情节丰富，我加了一句
                text(entity, '吉吉喵', `你任务没有完成，完成后再回来`);
            } else if (entity.jq == 3) {//如果剧情变量为3时，吉吉喵的任务完成了~
                text(entity, '吉吉喵', `啊哈哈哈哈哈哈哈哈哈哈哈哈我的任务完成啦~`);
            }
        })
    }
    if (npc.id == '雷电猴') {//如果他是雷电猴
        npc.onInteract(async ({ entity }) => {//判断互动
            if (entity.jq == 1) {//如果剧情变量为1时，雷电猴不知道发生了什么，为了使情节丰富，我又加了一句
                text(entity, '雷电猴', `hi`)
            } else if (entity.jq == 2) {//如果剧情变量为2时，雷电猴应该要把鸡汤喝了
                //以下是剧情
                text(entity, '雷电猴', `这是吉吉喵给我的鸡汤是吧，我试试，你看喝鸡汤多是一件美事啊~~`);
                text(entity, '雷电猴', `雷电猴喝下了鸡汤`);
                text(entity, '雷电猴', `任务2：回去找吉吉喵报道吧`)
                entity.player.directMessage('你的任务完成了，可以回去报道了')
                //变量调整，让玩家回去报道
                entity.jq = 3;
            } else if (entity.jq == 3) {//如果剧情变量为3时，雷电猴喝完了鸡汤，认为鸡汤味道好极了
                text(entity, '雷电猴', `这鸡汤不咸不淡，味道好极了！`);
            }
        })
    }
}
world.onPlayerJoin(async ({ entity }) => {//如果玩家进入地图，将玩家的剧情变量变成1
    entity.jq = 1;//剧情，用来判断剧情的变量
})
            </code>
        </pre>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="panel panel-default">
                                        <div class="panel-heading">
                                            <a class="panel-title collapsed" data-toggle="collapse"
                                                data-parent="#panel-586155" href="#panel-element-10">放个烟花</a>
                                        </div>
                                        <div id="panel-element-10" class="panel-collapse collapse">
                                            <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
                                                <pre>
            <code class="language-js">
              /**
 * !info {Project} -来自(shequ.codemao.cn/community/374423)@吉吉喵
 * 还记得“挑战32”颁奖典礼上吉吉喵控制的烟花效果吗？
 * 原理很简单：是通过粒子效果实现的
 */



console.clear()

function particleSpread(entity, colorList, scale = 1) {
    entity.particleRate = 550//粒子生成速率
    entity.particleLifetime = 2//粒子存活时间为2秒
    entity.particleColor = colorList//粒子的颜色列表
    entity.particleSize = [15 * scale, 10 * scale, 5 * scale, 2 * scale, scale]//粒子在5个阶段的大小
    entity.particleSizeSpread = 2 * scale//粒子的大小的随机变化幅度
    entity.particleVelocitySpread = [20 * scale, 20 * scale, 20 * scale]//粒子XYZ方向速度的随机变化幅度
    entity.particleAcceleration = [0, -10 * scale, 0]//粒子往下飘落模拟重力效果
}

const YELLOW = new Box3RGBColor(10, 10, 2)//黄
const CYAN = new Box3RGBColor(2, 10, 10)//青
const MAGENTA = new Box3RGBColor(10, 2, 10)//品红
const RED = new Box3RGBColor(10, 2, 2)//红
const GREEN = new Box3RGBColor(2, 10, 2)//绿
const BLUE = new Box3RGBColor(2, 2, 10)//蓝

//各个颜色5个粒子阶段的颜色列表
const ColorList = [
    [YELLOW, YELLOW, YELLOW, YELLOW, YELLOW],
    [CYAN, CYAN, CYAN, CYAN, CYAN],
    [MAGENTA, MAGENTA, MAGENTA, MAGENTA, MAGENTA],
    [RED, RED, RED, RED, RED],
    [GREEN, GREEN, GREEN, GREEN, GREEN],
    [BLUE, BLUE, BLUE, BLUE, BLUE],
]


function randomColor() {
    return ColorList[Math.floor(ColorList.length * Math.random())] //随机选取一个颜色列表
}

const MeshScale = [1 / 16, 1 / 16, 1 / 16] //默认的模型缩放系数
async function particleShoot(entity) {
    const fireball = world.createEntity({
        bounds: [0, 0, 0], // 隐形实体默认大小是1x1x1的方块, 现在把它从方块缩成大小为0x0x0的1个点
        collides: false, // 开启碰撞
        gravity: false, // 不受重力影响
        position: entity.position,
    })

    const color = randomColor()//随机颜色
    particleSpread(fireball, color, 0.3) //粒子大小系数缩到0.3, 形成小火球

    await sleep(100) // 等待0.1秒后升空
    fireball.velocity.set(0, 1, 0) // 火球速度为每秒向上1格

    await sleep(2000) //升空2秒后爆炸

    fireball.velocity.set(0, 0, 0) // 火球停止运动
    particleSpread(fireball, color, 1) // 系数增大到1, 让火球变大

    await sleep(1500) //大火球等待1.5秒后消失
    fireball.destroy()
}

const firework = world.querySelector('#新年烟花-1')
firework.enableInteract = true
firework.interactRadius = 3
firework.onInteract(async () => {
    var n = 3 //每次
    while (n-- > 0) {
        particleShoot(firework)//在"新年烟花-1"实体的位置发射烟花
        await sleep(2000)//每隔2秒射1发
    }
})
            </code>
        </pre>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="panel panel-default">
                                        <div class="panel-heading">
                                            <a class="panel-title collapsed" data-toggle="collapse"
                                                data-parent="#panel-586155" href="#panel-element-11">飞檐走壁</a>
                                        </div>
                                        <div id="panel-element-11" class="panel-collapse collapse">
                                            <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
                                                <pre>
            <code class="language-js">
              /**
 * !info {Project} -来自(shequ.codemao.cn/community/419110)@吉吉喵
 * 虽然阿吉是一只猫
 * 但一直有一个飞檐走壁的梦想
 * 今天这个教程，就是为了让你们化身超级英雄蜘蛛侠
 * 在城市山川间荡着蛛丝冒险～
 * 快来学习吧！
 */



console.clear()

/** --------------生成围墙的代码----------------- */
for (let x = 0; x < 126; x++) {
    for (let y = 9; y < 126; y++) {
        voxels.setVoxel(x, y, 0, 'stone')
        voxels.setVoxel(x, y, 125, 'stone')
    }
}
for (let z = 0; z < 126; z++) {
    for (let y = 9; y < 126; y++) {
        voxels.setVoxel(0, y, z, 'stone')
        voxels.setVoxel(125, y, z, 'stone')
    }
}
/** --------------生成围墙的代码----------------- */


world.onPlayerJoin(({ entity }) => {
    entity.player.onPress(async ({ raycast, button }) => {
        // 点击鼠标左键 发射蛛丝，并飞向蛛丝射中的位置
        if (button == Box3ButtonType.ACTION0) {

            // 首先实现发射蜘蛛丝的效果
            // 并拿到蜘蛛丝的实体做后续操作
            const spiderSilk = fireSpiderSilk(raycast, entity)

            // 使用animate模拟飞行过程中，蛛丝逐渐缩短的效果
            shortenSpiderSilk(raycast, spiderSilk)

            await sleep(1000)

            // 蛛丝开始缩放后，给玩家沿着蛛丝方向的速度，模拟蛛丝拉扯飞行的效果
            firePlayer(raycast, entity)

            // 最后要记得销毁蛛丝，避免卡顿
            await sleep(500)
            spiderSilk.destroy()
        }
    })
})

/** 发射玩家 */
function firePlayer(raycast, entity) {
    // 准心击中位置与玩家位置做向量减法，获得蛛丝的方向向量
    const direction = raycast.hitPosition.sub(entity.position)
    // 给方向向量乘以一个合适的系数，模拟玩家飞出去的效果。y轴速度小一些的原因是避免飞太高
    const velocity = new Box3Vector3(direction.x * 0.15, direction.y * 0.1, direction.z * 0.15)
    entity.velocity = velocity.clone()

    // 小技巧~~如果射中了其他玩家，可以给他一个反方向速度，模拟粘过来的效果
    if (raycast.hitEntity && raycast.hitEntity.isPlayer) {
        raycast.hitEntity.velocity = velocity.scale(-1)
    }
}

/** 蛛丝缩短的效果 */
function shortenSpiderSilk(raycast, spiderSilk) {
    // 飞行过程中，蛛丝变化的属性有：position、meshScale
    // 如果只缩短蛛丝，而不更改蛛丝位置，不能完整模拟出效果
    // 蛛丝初始生成位置
    const startPos = spiderSilk.position
    // 蛛丝在缩短的过程中需要移动到准心击中的位置
    const endPos = raycast.hitPosition
    // 蛛丝初始缩放值
    const initialScale = spiderSilk.meshScale
    // 蛛丝最终需沿x轴缩到最短
    const endScale = new Box3Vector3(0, 1 / 16, 1 / 16)
    const ani = spiderSilk.animate([
        { position: startPos, meshScale: initialScale, duration: 1 },
        { position: endPos, meshScale: endScale, duration: 0 },
    ])


    ani.play({
        duration: 16 * 0.45, // 播放过程0.45秒，如需更改缩放时间，更改这个数值。相应的也需更改玩家的飞行速度
        iterations: 1, // 只播放一次
        direction: Box3AnimationDirection.NORMAL, // 正常播放
    })
}

/** 发射蜘蛛丝 */
function fireSpiderSilk(raycast, entity) {
    // 摧毁准心对准的方块，用来标记击中的位置
    voxels.setVoxel(raycast.voxelIndex.x, raycast.voxelIndex.y, raycast.voxelIndex.z, 0)
    // 准心击中位置与玩家位置做向量减法，获得蛛丝的方向向量
    const direction = raycast.hitPosition.sub(entity.position)
    // 通过射出的方向向量，计算出蛛丝的旋转四元数
    const meshOrientation = getOrientationByVector(direction)
    // 准心击中位置与玩家位置的距离，为蛛丝的长度
    const distance = raycast.hitPosition.distance(entity.position)
    // 1/16 为基准缩放值。蛛丝的设计模型为沿x轴方向设计，且为两个方块长度。因此x轴缩放值为1 / 16 * distance / 2
    const initialScale = new Box3Vector3(1 / 16 * distance / 2, 1 / 16, 1 / 16)
    // 蛛丝的生成位置应为 准心击中位置与玩家位置的向量插值的中心点
    const initialPos = entity.position.lerp(raycast.hitPosition, 0.5)
    // 用各种计算好的数值创建蛛丝
    const spiderSilk = world.createEntity({
        mesh: "mesh/钢丝.vb",
        position: initialPos,
        collides: false,
        gravity: false,
        meshScale: initialScale,
        meshOrientation: meshOrientation
    })
    return spiderSilk
}

// 本示例中用到的钢丝模型为沿着x轴方向设计。因此用的Box3Quaternion(0, 0, 0, 1)四元数去做旋转计算
// 如果大家使用沿其他轴向设计的模型，请使用下面注释的四元数去做旋转计算
const Quat = new Box3Quaternion(0, 0, 0, 1) // 沿x轴方向设计的蛛丝，初始化四元数，用于旋转计算
// const Quat = new Box3Quaternion(0.000, 0.000, -0.707, 0.707) // 沿y轴方向设计的资源用
// const Quat = new Box3Quaternion(0.000, 0.707, 0.000, 0.707) // 沿z轴方向设计的资源用

/** 通过射出的方向向量，计算出蛛丝的旋转四元数 */
function getOrientationByVector(vector3) {
    const src = vector3
    let dx = src.x
    let dy = src.y
    let dz = src.z
    let dist = Math.sqrt(dx * dx + dz * dz)
    const rotx = Math.atan2(dy, dist)
    return Quat.rotateX(rotx).rotateY(Math.atan2(dz, dx))
}
            </code>
        </pre>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="panel panel-default">
                                        <div class="panel-heading">
                                            <a class="panel-title collapsed" data-toggle="collapse"
                                                data-parent="#panel-586155" href="#panel-element-12">分组</a>
                                        </div>
                                        <div id="panel-element-12" class="panel-collapse collapse">
                                            <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
                                                <pre>
            <code class="language-js">
              /**
 * !info {Project} -来自(shequ.codemao.cn/community/379286)@吉吉喵
 * 分组PK是一种常见的多人游戏模式
 * 今天吉吉喵就叫你如何给玩家分组对战～
 */



function joinRed(entity) {
    entity.addTag('red')//加红队标签
    entity.player.color.set(1, 0, 0)//变红
    world.say(`${entity.player.name} 被分配到红队`)
}

function joinBlue(entity) {
    entity.addTag('blue')//加蓝队标签
    entity.player.color.set(0, 0, 1)//变蓝
    world.say(`${entity.player.name} 被分配到蓝队`)
}

world.onPlayerJoin(({ entity }) => {

    const red = world.querySelectorAll('.red') //红队玩家列表
    const blue = world.querySelectorAll('.blue') //蓝队玩家列表
    if (red.length === blue.length) {//如果两队人数相同
        if (Math.random() < 0.5) {//随机加入其中一队
            joinBlue(entity)//加入蓝队
        }
        else {
            joinRed(entity)//加入红队
        }
    }
    else if (red.length > blue.length) {//如果红队人多
        joinBlue(entity)//加入蓝队
    }
    else {
        joinRed(entity)//加入红队
    }

})
            </code>
        </pre>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="panel panel-default">
                                        <div class="panel-heading">
                                            <a class="panel-title collapsed" data-toggle="collapse"
                                                data-parent="#panel-586155" href="#panel-element-13">分组对战</a>
                                        </div>
                                        <div id="panel-element-13" class="panel-collapse collapse">
                                            <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
                                                <pre>
            <code class="language-js">
              /**
 * !info {Project} -来自(shequ.codemao.cn/community/388136)@吉吉喵
 * 给玩家分组对战的进阶版教程来力！
 */



function joinRed(entity) {
    entity.addTag('red')//加红队标签
    entity.player.color.set(1, 0, 0)//变红
    world.say(`${entity.player.name} 被分配到红队`)
    entity.player.spawnPoint.set(5, 10, 64)//设置红队的出生点在地图的一边
}

function joinBlue(entity) {
    entity.addTag('blue')//加蓝队标签
    entity.player.color.set(0, 0, 1)//变蓝
    world.say(`${entity.player.name} 被分配到蓝队`)
    entity.player.spawnPoint.set(122, 10, 64)//设置蓝队的出生点在地图的另一边
}

world.onPlayerJoin(({ entity }) => {

    const red = world.querySelectorAll('.red') //红队玩家列表
    const blue = world.querySelectorAll('.blue') //蓝队玩家列表
    if (red.length === blue.length) {//如果两队人数相同
        if (Math.random() < 0.5) {//随机加入其中一队
            joinBlue(entity)//加入蓝队
        }
        else {
            joinRed(entity)//加入红队
        }
    }
    else if (red.length > blue.length) {//如果红队人多
        joinBlue(entity)//加入蓝队
    }
    else {
        joinRed(entity)//加入红队
    }

    entity.player.forceRespawn() //传送到自己队伍的出生点
    entity.enableDamage = true //允许玩家受伤
    entity.score = 0 //玩家初始得分为0
    entity.onDie(async ({ attacker }) => {
        let attackerTeam = teamName(attacker)//对手的队名
        let myTeam = teamName(entity)//玩家的队名

        world.say(`[${attackerTeam}]${attacker.player.name} 击败了 [${myTeam}]${entity.player.name}`)
        attacker.score += 1 //当玩家被击败时, 给对手加1分

        await sleep(5000) //等待5秒后复活
        entity.player.forceRespawn() //满血回到出生点
    })
})

function teamName(entity) {
    if (entity.hasTag('red')) {//如果有红队标签
        return '红队'
    }
    else if (entity.hasTag('blue')) {//如果有蓝队标签
        return '蓝队'
    }
    return '未知队伍'
}

world.onClick(({ entity, clicker }) => {
    if ( //如果攻击者和被击者在不同的队伍, 则被击者会受伤
        (entity.hasTag('red') && clicker.hasTag('blue')) || //被击者是红队, 攻击者是蓝队
        (entity.hasTag('blue') && clicker.hasTag('red')) //或者 被击者是蓝队, 攻击者是红队
    ) {
        entity.hurt(10, { attacker: clicker }) //被点击者受到10点伤害, 并将点击者传递给onDie事件
    }
})

world.onPress(({ entity, button }) => {
    if (button == Box3ButtonType.ACTION1) { //右键查看自己的分数
        entity.player.dialog({
            type: Box3DialogType.TEXT,
            content: `本回合你击败了${entity.score}个对手`
        })
    }
})
            </code>
        </pre>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="panel panel-default">
                                        <div class="panel-heading">
                                            <a class="panel-title collapsed" data-toggle="collapse"
                                                data-parent="#panel-586155" href="#panel-element-14">氛围倒计时</a>
                                        </div>
                                        <div id="panel-element-14" class="panel-collapse collapse">
                                            <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
                                                <pre>
            <code class="language-js">
              /**
 * !info {Project} -来自(shequ.codemao.cn/community/418160)@吉吉喵
 * 还记得编程猫博物馆颁奖典礼前炫酷的倒计时吗？
 * 氛围感拉满～
 */



console.clear()

/**
 * 字符形状对应的方块点位
 * 值为1，则显示方块
 * 值为0，则不显示方块
 * 以此来拼凑出字符的形状
 */
const charMap = {
    '0': [
        [1, 1, 1],
        [1, 0, 1],
        [1, 0, 1],
        [1, 0, 1],
        [1, 1, 1],
    ],
    '1': [
        [0, 1, 0],
        [0, 1, 0],
        [0, 1, 0],
        [0, 1, 0],
        [0, 1, 0],
    ],
    '2': [
        [1, 1, 1],
        [0, 0, 1],
        [1, 1, 1],
        [1, 0, 0],
        [1, 1, 1],
    ],
    '3': [
        [1, 1, 1],
        [0, 0, 1],
        [1, 1, 1],
        [0, 0, 1],
        [1, 1, 1],
    ],
    '4': [
        [1, 0, 1],
        [1, 0, 1],
        [1, 1, 1],
        [0, 0, 1],
        [0, 0, 1],
    ],
    '5': [
        [1, 1, 1],
        [1, 0, 0],
        [1, 1, 1],
        [0, 0, 1],
        [1, 1, 1],
    ],
    '6': [
        [1, 1, 1],
        [1, 0, 0],
        [1, 1, 1],
        [1, 0, 1],
        [1, 1, 1],
    ],
    '7': [
        [1, 1, 1],
        [0, 0, 1],
        [0, 0, 1],
        [0, 0, 1],
        [0, 0, 1],
    ],
    '8': [
        [1, 1, 1],
        [1, 0, 1],
        [1, 1, 1],
        [1, 0, 1],
        [1, 1, 1],
    ],
    '9': [
        [1, 1, 1],
        [1, 0, 1],
        [1, 1, 1],
        [0, 0, 1],
        [1, 1, 1],
    ],
    ':': [
        [0, 0, 0],
        [0, 1, 0],
        [0, 0, 0],
        [0, 1, 0],
        [0, 0, 0],
    ],
}

/**
 * 渲染一个字符
 * @parame char 需渲染的字符
 * @parame position 字符左上角位置
 */
function renderOneChar(char, position) {
    // 获取字符对应的方块点位，点位数据为二维数组
    const charData = charMap[char]
    // 遍历点位二维数组
    for (let i = 0; i < charData.length; i++) {
        const row = charData[i]
        // 遍历点位第i行
        for (let j = 0; j < row.length; j++) {
            const value = row[j]
            // 每一行方块的x坐标，随着列数增加而增加
            const x = position.x + j
            // 每一行方块的y坐标，随着行数增加而降低
            const y = position.y - i
            // 每一行方块的z坐标相同
            const z = position.z
            if (value == 0) {
                // 值为0，则不显示方块
                voxels.setVoxelId(x, y, z, 0)
            } else {
                voxels.setVoxel(x, y, z, 'red_light')
            }
        }
    }
}

/**-------------测试 renderOneChar 函数---------------- */
renderOneChar('2', new Box3Vector3(20, 20, 20))
/**-------------测试 renderOneChar 函数---------------- */



/**
 * 渲染一个字符串
 * @parame str 需渲染的字符串
 * @parame position 字符串第一个字符的左上角位置
 */
function renderString(str, position) {
    // 遍历每个字符，依次渲染
    for (let i = 0; i < str.length; i++) {
        // 观察charMap可知每个字符占用宽度为3，再加上字符间应有间距,因此每个字符的x要相距4
        const pos = position.add(new Box3Vector3(4 * i, 0, 0))
        renderOneChar(str[i], pos)
    }
}

/**-------------测试 renderString 函数---------------- */
renderString('22', new Box3Vector3(35, 20, 20))
/**-------------测试 renderString 函数---------------- */



/** 获取符合00：00格式的字符串 */
function getTimeStr(time) {
    if (time > 0) {
        if (time >= 10) {
            t = time
        } else {
            // 小于10时，前面补一个0
            t = '0' + time
        }
    } else {
        // 等于0时，用两个0代替
        t = '00'
    }
    return t
}

/**
 * 开始倒计时
 * @parame totalTime  总计时（单位：秒）
 * @parame position 倒计时的左上角位置
 */
async function startCountDown(totalTime, position) {
    let time = totalTime
    // 每隔1秒判断一次，直到时间减为0
    while (time >= 0) {
        // 获得分钟数
        const minute = Math.floor(time / 60)
        // 获得秒数
        const second = time % 60
        // 转化为符合规则的字符串
        const minuteStr = getTimeStr(minute)
        // 转化为符合规则的字符串
        const secondStr = getTimeStr(second)
        // 用":"拼凑出时间字符串
        const timeStr = minuteStr + ':' + secondStr
        // 渲染出时间字符串
        renderString(timeStr, position)
        // 每隔1秒 时间变量减一
        await sleep(1000)
        time--
    }
}

/**-------------测试 startCountDown 函数---------------- */
// 总倒计时 72秒
const totalTime = 72
// 倒计时的左上角位置
const position = new Box3Vector3(55, 20, 20)
startCountDown(totalTime, position)
/**-------------测试 startCountDown 函数---------------- */

            </code>
        </pre>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="panel panel-default">
                                        <div class="panel-heading">
                                            <a class="panel-title collapsed" data-toggle="collapse"
                                                data-parent="#panel-586155" href="#panel-element-15">俯瞰地图</a>
                                        </div>
                                        <div id="panel-element-15" class="panel-collapse collapse">
                                            <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
                                                <pre>
            <code class="language-js">
              /**
 * !info {Project} -来自(shequ.codemao.cn/community/419961)@吉吉喵
 * 当你的地图面积非常大时
 * 如何才能快速看到全景、并定位自己所在的位置？
 * 今天这招，就教你们“登高望远”
 * 俯瞰地图全景：
 */



// 点击鼠标右键（B），弹出对话框，视线变为俯视
world.onPlayerJoin(({ entity }) => {
    entity.player.onPress(async ({ button }) => {
        if (button == Box3ButtonType.ACTION1) {
            // 将摄像机看向地图中心
            const lookTarget = new Box3Vector3(63, 8, 63);

            // 将摄像机的位置置于地图大概中心处，并往上拉升到y轴150处，确保看到完整的地形
            const lookEye = new Box3Vector3(63, 150, 63);

            // lookUp用来调整相机角度，可以使画面上下左右颠倒。默认值是(0,1,0)
            // 由于视线是俯视，需要确保lookUp与相机视线方向不平行,需修改为(1,0,0)或者(0,0,1)
            const lookUp = new Box3Vector3(1, 0, 0)

            entity.player.dialog({
                type: Box3DialogType.TEXT,
                content: `俯视`,
                lookEye: lookEye,
                lookTarget: lookTarget,
                lookUp: lookUp
            })
        }
    })
})



// 实现多个方向的效果
// 我们生成一个浮在空中的立方体,每个面颜色不同，方便实现6个方向的观察测试。
function cube(sx, sy, sz, xsize, ysize, zsize) {
    var xend = sx + xsize
    var yend = sy + ysize
    var zend = sz + zsize
    for (var x = sx; x < xend; x++) {
        for (var y = sy; y < yend; y++) {
            for (var z = sz; z < zend; z++) {
                if (x === sx) {
                    voxels.setVoxel(x, y, z, 'green_light')
                }
                if (x === xend - 1) {
                    voxels.setVoxel(x, y, z, 'red_light')
                }
                if (y === sy) {
                    voxels.setVoxel(x, y, z, 'black')
                }
                if (y === yend - 1) {
                    voxels.setVoxel(x, y, z, 'white_light')
                }
                if (z === sz) {
                    voxels.setVoxel(x, y, z, 'blue_light')
                }
                if (z === zend - 1) {
                    voxels.setVoxel(x, y, z, 'yellow_light')
                }
            }
        }
    }
}

//在{x:50, y:50, z:50} 位置，建造一个长20格，宽20格，高20格的空心立方体
cube(50, 50, 50, 20, 20, 20)



world.onPlayerJoin(({ entity }) => {
    entity.player.onPress(async ({ button }) => {
        if (button == Box3ButtonType.ACTION0) {
            let loop = true
            // 只要不是选择了退出，都反复让用户选择要看的颜色那一面
            while (loop) {
                let sel = await entity.player.dialog({
                    type: Box3DialogType.SELECT,
                    content: '选择要看的颜色',
                    options: ['黄色', '蓝色', '红色', '绿色', '白色', '黑色', '退出']
                })

                if (sel) {
                    // 初始化相机参数
                    const lookTarget = new Box3Vector3(0, 0, 0)
                    const lookEye = new Box3Vector3(0, 0, 0)
                    const lookUp = new Box3Vector3(0, 1, 0)


                    // 根据选择的颜色，将lookTarget设置为所看颜色面的中心点坐标
                    // 并将lookEye沿着视线拉远距离

                    // z轴视线
                    if (sel.value == '黄色') {
                        lookTarget.set(60, 60, 50)
                        lookEye.set(60, 60, 180)
                    }
                    // z轴视线
                    if (sel.value == '蓝色') {
                        lookTarget.set(60, 60, 50)
                        lookEye.set(60, 60, -60)
                    }
                    // x轴视线
                    if (sel.value == '红色') {
                        lookTarget.set(50, 60, 60)
                        lookEye.set(180, 60, 60)
                    }
                    // x轴视线
                    if (sel.value == '绿色') {
                        lookTarget.set(50, 60, 60)
                        lookEye.set(-60, 60, 60)
                    }
                    // y轴视线俯视
                    if (sel.value == '白色') {
                        lookTarget.set(60, 70, 60)
                        lookEye.set(60, 150, 60)
                        // 相机lookUp与相机视线方向不能平行，需修改为(1,0,0)或者(0,0,1)
                        lookUp.set(1, 0, 0)
                    }
                    // y轴视线仰视
                    if (sel.value == '黑色') {
                        lookTarget.set(60, 70, 60)
                        lookEye.set(60, 10, 60)
                        // 相机lookUp与相机视线方向不能平行，需修改为(1,0,0)或者(0,0,1)
                        lookUp.set(0, 0, 1)
                    }
                    if (sel.value == '退出') {
                        // 用户选择退出，则退出选择界面
                        loop = false
                    } else {

                        // 使用用户选择所对应的参数来设置相机，并弹出对话框
                        await entity.player.dialog({
                            type: Box3DialogType.TEXT,
                            content: `看向${sel.value}面`,
                            lookEye: lookEye,
                            lookTarget: lookTarget,
                            lookUp: lookUp
                        })
                    }
                }
            }
        }
    })
})
            </code>
        </pre>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="panel panel-default">
                                        <div class="panel-heading">
                                            <a class="panel-title collapsed" data-toggle="collapse"
                                                data-parent="#panel-586155" href="#panel-element-16">可穿戴设备</a>
                                        </div>
                                        <div id="panel-element-16" class="panel-collapse collapse">
                                            <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
                                                <pre>
            <code class="language-js">
              /**
 * !info {Project} -来自(shequ.codemao.cn/community/374598)@吉吉喵
 * 皮肤虽然有限
 * 但可穿戴装备是无限的！
 * 学会这项技能
 * 你就是岛上最靓的崽～
 */



world.onPlayerJoin(({entity}) => {
    entity.player.addWearable({
        bodyPart: Box3BodyPart.HEAD,
        mesh: 'mesh/三级盔.vb',
        orientation: new Box3Quaternion(0,1,0,0).rotateY(-Math.PI/2),
        offset: new Box3Vector3(0,0.4,0.1),
    });
    entity.player.addWearable({
        bodyPart: Box3BodyPart.RIGHT_HAND,
        mesh: 'mesh/95式 [精美].vb',
        orientation: new Box3Quaternion(0,1,0,0).rotateY(Math.PI),
        offset: new Box3Vector3(-0.05,-0.1,0.5),
        scale: Box3Vector3 = new Box3Vector3(0.3, 0.3, 0.3),
    });
});

            </code>
        </pre>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="panel panel-default">
                                        <div class="panel-heading">
                                            <a class="panel-title collapsed" data-toggle="collapse"
                                                data-parent="#panel-586155" href="#panel-element-17">满足人数开始游戏</a>
                                        </div>
                                        <div id="panel-element-17" class="panel-collapse collapse">
                                            <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
                                                <pre>
            <code class="language-js">
              /**
 * !info {Project} -来自(shequ.codemao.cn/community/439092)@BZIClaw
 * 实现的效果是当地图内玩家人数满足3人时游戏开局！
 */



console.clear();  // 清空控制台

world.onPlayerJoin(({ entity }) => {  // 当实体进入地图
    if (entity.isPlayer) {  // 如果实体是一个玩家
        entity.addTag('NotInGame');  // 添加标签 “不在游戏中”
        if (world.querySelectorAll('player').length >= 3) {  // 如果玩家的数量 >= 3 则开始游戏
            for (const c of world.querySelectorAll('.NotInGame')) {  // 让所有不在游戏中的玩家传送到 “游戏区”
                c.player.spawnPoint.set(60, 15, 76);  // 重新重生点
                c.player.forceRespawn();  // 强制传送
                c.removeTag('NotInGame');  // 删掉标签 “不在游戏中”
                c.player.dialog({  // 对话框
                    type: Box3DialogType.TEXT,
                    title: `欢迎`,
                    content: `人数已超过 3 人，可进入游戏~~`
                })
            }
        } 
        else {  // 如果玩家人数不够，就执行这些代码
            entity.player.spawnPoint.set(41, 37, 44);  // 在上层 “休息区” 出生
            entity.player.forceRespawn();  // 强制传送（重生）
            entity.player.dialog({  // 发送对话框
                type: Box3DialogType.TEXT,
                title: `欢迎`,
                content: `目前人数未达到 3 人，请等待其他玩家进入~~`
            })
        }
    }
});
            </code>
        </pre>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="panel panel-default">
                                        <div class="panel-heading">
                                            <a class="panel-title collapsed" data-toggle="collapse"
                                                data-parent="#panel-586155" href="#panel-element-18">排行榜</a>
                                        </div>
                                        <div id="panel-element-18" class="panel-collapse collapse">
                                            <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
                                                <pre>
            <code class="language-js">
              /**
 * !info {Project} -来自(shequ.codemao.cn/community/415223)@吉吉喵
 * 圣诞创作节下半场已经在昨天开启
 * “第一才有圣诞礼物”这个主题让你想到什么呢？
 * 没错，就是排行榜！
 * 加入这个功能，一定会让你的参赛作品赢面更大～
 */



// 当玩家进入游戏时
world.onPlayerJoin(({ entity }) => {
    // 设置刚进入游戏的玩家持有金币(coin)数量为0
    entity.player.coin = 0
    // 当玩家按下按键时，触发交互
    entity.player.onPress(({ button }) => {
        if (button === Box3ButtonType.ACTION0) {
            entity.player.dialog({
                type: Box3DialogType.TEXT,
                title: "金币排行榜",
                content: dialogContent(),
            })
        }
    })
});

// 找到世界中的"AT M"机器模型
const atm = world.querySelector(`#A喵`)
// 设置AT M机器可互动
atm.enableInteract = true
// 设置AT M机器互动距离为5
atm.interactRadius = 5;

// 监听世界中的互动事件
world.onInteract(({ entity, targetEntity }) => {
    // 判断被"互动"的实体，
    if (targetEntity.id === "A喵") {
        entity.player.coin = entity.player.coin + 1;
        world.say(`${entity.player.name}获得了1金币！`);
    }
})

// 对话框内容
function dialogContent() {
    // 首先获取当前世界中的所有玩家
    const allPlayerEntities = world.querySelectorAll('player');
    // 然后将所有的玩家进行排序，排序的规则是按照玩家持有的金币数量降序
    const sortedPlayerEntities = allPlayerEntities.sort((a, b)=>  b.player.coin - a.player.coin);
    
    
    // 接下来，我们将在排行榜上以: xxx 有 yyy 个金币 的格式展示，并且每一条信息换一行显示！

        // 首先声明一个content字符串，一会用来保存每一个玩家的信息
        let content = "";
    // 在这里需要做一个循环遍历，将刚才得到的有序的玩家数组遍历一遍
    for(const entity of sortedPlayerEntities ) {
        // 在遍历的过程中，每一次遍历，我们拿到当前的实体(entity)，
        // 将实体上的玩家名字(player.name)以及玩家金币数量(player.coin)拼接成排行榜上的一行信息
        // 这样就得到: xxx 有 yyy 个金币 的格式啦
        // 我们在这个文字的末尾加一个\n, 这样我们就能实现换行的效果
        // 紧接着，再把这行信息加上content，这样做是为了把每一个玩家的排行榜信息拼接起来，保存到content中
        content = content + `${entity.player.name}有${entity.player.coin}个金币\n`
    }
    // 最后，把得到的完整的带有玩家名称和金币数量，并且会换行的排行榜数据(content)返回出去
    return content
}
            </code>
        </pre>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="panel panel-default">
                                        <div class="panel-heading">
                                            <a class="panel-title collapsed" data-toggle="collapse"
                                                data-parent="#panel-586155" href="#panel-element-19">区域范围攻击</a>
                                        </div>
                                        <div id="panel-element-19" class="panel-collapse collapse">
                                            <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
                                                <pre>
            <code class="language-js">
              /**
 * !info {Project} -来自(shequ.codemao.cn/community/433216)@可乐OωO
 * 区域范围攻击
 */



console.clear(); //清空控制台信息
const Quat = new Box3Quaternion(0, 0, 0, 1); //初始化四元数，用于旋转
const e = world.querySelector('#炮台'); //获取炮台实体

world.onPlayerJoin(({ entity }) => { //当玩家进入时
    entity.position.set(32, 13, 32); //设置玩家的坐标为 { x: 32, y: 13, z: 32 }
    entity.player.spawnPoint.copy(entity.position); //设置玩家的重生点为位置，也就是 { x: 32, y: 13, z: 32 }
    entity.enableDamage = true; //让玩家允许受到伤害
});

const zone = world.addZone({ //添加一个炮台检测的区域
    selector: 'player', //区域内的物体搜索条件，这里为玩家
    bounds: { //指定检测区域
        lo: e.position.sub({ x: 15, y: 2, z: 15 }), //最低点，这里用位置的sub方法来实现一个位置减去另一个位置的功能
        hi: e.position.add({ x: 15, y: 5, z: 15 }), //最高点，这里用位置的add方法来实现一个位置加上另一个位置的功能
    },
});

zone.onEnter(({ entity }) => { //如果炮台检测的区域进入了玩家
    entity.interval = setInterval(async () => { //每2秒执行一次，把这个程序放在entity.interval中
        if (zone.entities().includes(entity)) { //如果玩家在这个区域里
            let direction = entity.position.sub(e.position); //用位置的sub方法算出方向
            let face = direction.clone(); //用clone函数复制一个一样的位置对象
            let d = Quat.rotateY(Math.atan2(face.z, face.x)); //用初始化四元数的rotateY方法来旋转Y轴，用atan2函数来计算旋转弧度，这样我们就得到了一个玩家方向的四元数
            e.meshOrientation = d; //设置子弹的旋转值为玩家方向

            let bullet = world.createEntity({ //创建一个子弹实体
                mesh: 'mesh/子弹.vb', //模型为子弹模型
                meshScale: [1/16, 1/16, 1/16], //大小为默认大小，[1/16, 1/16, 1/16]
                collides: true, //开启碰撞
                gravity: false, //不受重力影响
                position: e.position, //在玩家的位置生成子弹
                velocity: face.scale(0.15), //子弹的初速度是玩家方向，因为速度太快了，所以要用位置的scale方法来把xyz各乘上0.15
                meshOrientation: d.rotateY(Math.PI / 2), //子弹的头指向玩家，这里还需要用四元数的rotateY方法来旋转90度
            });

            bullet.onEntityContact(({ other }) => { //每当子弹碰到另一个实体
                if (other.hp > 0) { //如果这个实体的血量大于0
                    other.hurt(10, { //被碰实体受10点伤害
                        damageType: '炮台的子弹', //伤害类型设为“炮台的子弹” 
                    });
                    bullet.destroy(); //攻击之后子弹消失，防止重复攻击
                }
            });

            await sleep(1500); //等1.5秒后
            if (!bullet.destroyed) { //如果这个子弹还没有清除
                bullet.destroy(); //清除子弹，防止子弹数量太多超过服务器负载
            }
        }
    }, 2000);
});

zone.onLeave(({ entity }) => {
    if (entity.interval) clearInterval(entity.interval); //如果entity.interval这个程序存在，把每2秒执行一次的子弹程序取消，防止多个子弹程序一起发生
});

world.onDie(async ({ entity, damageType }) => { //当有玩家S亡时
    if (entity.interval) clearInterval(entity.interval); //如果entity.interval这个程序存在，把每2秒执行一次的子弹程序取消，防止多个子弹程序一起发生
    while (1) { //无限循环，防止玩家点“×”
        let respawnDialog = await entity.player.dialog({ //该玩家弹出一个对话框
            type: Box3DialogType.SELECT, //类型为选择对话框
            title: '死亡提示', //将对话框的标题设为“死亡提示”
            content: `你被 ${damageType} 击杀了`, //将对话框的内容设为一个模板字符串，拼接方式为 '你被' + damageType + '击杀了'
            options: ['重生'], //对话框的选项只有一个，就是“重生”
        });

        if (respawnDialog) { //如果玩家点击了选项（因为选项只有一个，所以这行代码的意思还可以是“如果玩家点击了‘重生’”）
            entity.player.forceRespawn(); //让玩家重生
            break; //退出无限循环
        } //这里不用判断“如果玩家没有点击选项”了，因为这是无限循环，如果不点击选项就没有break，自然就直接进行下一轮循环（重新弹出一遍对话框）了
    }
});
            </code>
        </pre>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="panel panel-default">
                                        <div class="panel-heading">
                                            <a class="panel-title collapsed" data-toggle="collapse"
                                                data-parent="#panel-586155" href="#panel-element-20">让模型几秒钟后消失</a>
                                        </div>
                                        <div id="panel-element-20" class="panel-collapse collapse">
                                            <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
                                                <pre>
            <code class="language-js">
              /**
 * !info {Project} -来自(shequ.codemao.cn/community/363908)@吉吉喵
 * 只需要下面这串神奇的代码
 * 就能让模型在固定的时间消失！
 */



async function hideAfter3Sec(entity) {
    await sleep(3000)
    entity.meshInvisible = true
  }
  
  hideAfter3Sec(world.querySelector('#灯笼'))
            </code>
        </pre>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="panel panel-default">
                                        <div class="panel-heading">
                                            <a class="panel-title collapsed" data-toggle="collapse"
                                                data-parent="#panel-586155" href="#panel-element-21">山丘生成</a>
                                        </div>
                                        <div id="panel-element-21" class="panel-collapse collapse">
                                            <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
                                                <pre>
            <code class="language-js">
              /**
 * !info {Project} -来自(shequ.codemao.cn/community/362114)@吉吉喵
 * -生成山丘的代码-
 */



function cylinder(cx, cy, cz, vox, radius, height) {
    var xend = cx + radius;
    var yend = cy + height;
    var zend = cz + radius;
    for (var x = cx - radius; x <= xend; x++) {
        for (var z = cz - radius; z <= zend; z++) {
            var dx = x - cx;
            var dz = z - cz;
            if (Math.round(Math.sqrt(dx * dx + dz * dz)) <= radius) {
                for (var y = cy; y < yend; y++) {
                    voxels.setVoxel(x, y, z, vox);
                }
            }
        }
    }
}

for (var i = 0; i < 300; i++) { /* 300个随机圆柱体构成场景 */
    let x = Math.random() * 125; /* x坐标 */
    let z = Math.random() * 125; /* z坐标 */
    let h = Math.random() * 4; /* 高 0~3.9999 */
    let r = 2 + Math.random() * 5; /* 半径 2~6.9999 */
    cylinder(x, 9, z, 'dirt', r, h);
}

for (var y = 9; y < 13; y++) { /* 扫描9~12层的格子 */
    for (var x = 0; x < 127; x++) {
        for (var z = 0; z < 127; z++) {
            /* 如果当前格子不为空而它上面那格是空的, 则表示它是复杂地形的表面 */
            if (voxels.getVoxel(x, y, z) != 0 && voxels.getVoxel(x, y + 1, z) == 0) {
                voxels.setVoxel(x, y, z, 'grass'); /* 土块替换成草地 */
            }
        }
    }
}
            </code>
        </pre>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="panel panel-default">
                                        <div class="panel-heading">
                                            <a class="panel-title collapsed" data-toggle="collapse"
                                                data-parent="#panel-586155" href="#panel-element-22">设置进阶版复活点</a>
                                        </div>
                                        <div id="panel-element-22" class="panel-collapse collapse">
                                            <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
                                                <pre>
            <code class="language-js">
              /**
 * !info {Project} -来自(shequ.codemao.cn/community/416346)@吉吉喵
 * 跑酷、pvp游戏必备的小技巧来啦！
 * 学会这三种进阶版的复活点写法
 * 基本上就能驾驭大部分的地图玩法了～
 */



// 获取场景里的复活点模型，命名为respawnPoint
// 具体模型可以用任意你喜欢的模型替换，名称也可以替换成你想要的命名
const respawnPoint = world.querySelector(`#复活点`)

// 监听方块与实体的碰撞
world.onVoxelContact(({entity, voxel})=> {
    // 将方块id转换名称
    const voxelName = voxels.name(voxel);
    // 如果方块名称是熔岩
    if (voxelName === 'lava02'){
        // 使实体受到100点伤害
        // 目的是为了直接触发实体的'onDie'事件
        //  *这里为了方便演示，将伤害值直接调到生命值(hp)的上限100点，
        //   具体调到多少点可以自行设置，只要玩家累计受到100点伤害就会触发entity的'onDie'事件
        entity.hurt(100)
    }
})

// 当玩家进入地图时
world.onPlayerJoin(({ entity }) => {
    // 首先要开启enableDamage(允许伤害)，如果不设置为true的话，玩家是不会受到伤害的！
    entity.enableDamage = true
    // 给玩家的'onDie'事件添加处理的逻辑
    // 'onDie'事件会在玩家的生命值(hp)减少到0及以下时触发
    entity.onDie(() => {
        // 设置复活点的主要API: entity.player.spawnPoint

        // 1.在指定位置复活。
        // 复活点设置为世界里的'复活点模型'的坐标(position)
        // 当角色复活的时候就会出现在'复活点模型'的位置上
        // -------------------------打开下面一行注释测试效果，同时给2&3的代码注释掉---------------------------------
        entity.player.spawnPoint = respawnPoint.position.clone();
        // -------------------------打开上面一行注释测试效果，同时给2&3的代码注释掉---------------------------------

        // 2.在指定区域复活
        // const xPos = 72 + Math.random() * 5
        // const zPos = 63 + Math.random() * 5
        // entity.player.spawnPoint = new Box3Vector3(xPos, 15, zPos);


        // 3.在随机区域复活
        // const xPos = 0 + Math.random() * 126
        // const zPos = 0 + Math.random() * 126
        // entity.player.spawnPoint = new Box3Vector3(xPos, 15, zPos);

        // 设置好复活点之后，记得调用forceRespawn() API
        // 这样就可以强制玩家复活到上面设置好的位置了
        entity.player.forceRespawn()
    })
})
            </code>
        </pre>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="panel panel-default">
                                        <div class="panel-heading">
                                            <a class="panel-title collapsed" data-toggle="collapse"
                                                data-parent="#panel-586155" href="#panel-element-23">生成随机数</a>
                                        </div>
                                        <div id="panel-element-23" class="panel-collapse collapse">
                                            <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
                                                <pre>
            <code class="language-js">
              /**
 * !info {Project} -来自(shequ.codemao.cn/community/364404)@吉吉喵
 * 随机生成小鸡
 */



(Math.random()*20,11,Math.random()*20)
            </code>
        </pre>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="panel panel-default">
                                        <div class="panel-heading">
                                            <a class="panel-title collapsed" data-toggle="collapse"
                                                data-parent="#panel-586155" href="#panel-element-24">天气变化</a>
                                        </div>
                                        <div id="panel-element-24" class="panel-collapse collapse">
                                            <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
                                                <pre>
            <code class="language-js">
              /**
 * !info {Project} -来自(shequ.codemao.cn/community/413663)@吉吉喵
 * 久违的小技巧教程来也！
 * 今天带来的是一个非常简单的小教程：
 * 让每一天都随机出现不同的天气
 * 能够很好的配合地图场景需要
 * 非常实用哦
 */



//在左侧工具栏点击 场景->全局特效 打开"飘雪"才能使下雪代码生效
world.snowTexture = 'snow/snow.part'



async function init() {

    while (true) {//无限循环
        if (Math.random() < 0.5) {
            world.rainDensity = 0//停雨
        }
        else {
            world.rainDensity = 0.5//下雨
        }

        if (Math.random() < 0.5) {
            world.snowDensity = 0//停雪
        }
        else {
            world.snowDensity = 0.1//下雪
        }

        if (Math.random() < 0.5) {//停雾
            world.fogUnifor喵ensity = 0
        }
        else {//起雾
            world.fogUnifor喵ensity = 0.1
        }

        world.sunPhase = 0.25 //白天
        await sleep(5000)//等待5000毫秒

        world.sunPhase = 0.75 //黑夜
        await sleep(10000)//等待10000毫秒
      }
}

init()
            </code>
        </pre>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</body>

</html>